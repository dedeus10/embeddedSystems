<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RealTime_Home: SAM Serial Peripheral Interface (SERCOM SPI) Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RealTime_Home
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__asfdoc__sam0__sercom__spi__group.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SAM Serial Peripheral Interface (SERCOM SPI) Driver</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__module.html">spi_module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SERCOM SPI driver software device instance structure.  <a href="structspi__module.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__slave__inst.html">spi_slave_inst</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI peripheral slave instance structure.  <a href="structspi__slave__inst.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__slave__inst__config.html">spi_slave_inst_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI peripheral slave configuration structure.  <a href="structspi__slave__inst__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__master__config.html">spi_master_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI Master configuration structure.  <a href="structspi__master__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__slave__config.html">spi_slave_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI slave configuration structure.  <a href="structspi__slave__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structspi__config.html">spi_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI configuration structure.  <a href="structspi__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae7bc85650aed61f97fe3d5df9b430456"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gae7bc85650aed61f97fe3d5df9b430456">PINMUX_DEFAULT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:gae7bc85650aed61f97fe3d5df9b430456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffde9ff712058ef836127e1f3368889e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gaffde9ff712058ef836127e1f3368889e">PINMUX_UNUSED</a>&#160;&#160;&#160;0xFFFFFFFF</td></tr>
<tr class="separator:gaffde9ff712058ef836127e1f3368889e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0131f2774f4e3dd71567400683b60405"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga0131f2774f4e3dd71567400683b60405">SPI_TIMEOUT</a>&#160;&#160;&#160;10000</td></tr>
<tr class="separator:ga0131f2774f4e3dd71567400683b60405"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga88d771c03a254735de0053be3fa513ca"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga88d771c03a254735de0053be3fa513ca">spi_callback_t</a>) (struct <a class="el" href="structspi__module.html">spi_module</a> *const module)</td></tr>
<tr class="separator:ga88d771c03a254735de0053be3fa513ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga4afb8830e0197ec11f6beb8140210a88"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga4afb8830e0197ec11f6beb8140210a88">spi_callback</a> { <br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga4afb8830e0197ec11f6beb8140210a88a457c19f75d284d1664cc38b0f1e1eb81">SPI_CALLBACK_BUFFER_TRANSMITTED</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga4afb8830e0197ec11f6beb8140210a88a7da8cc036860fc86ef36aeeffe9088ec">SPI_CALLBACK_BUFFER_RECEIVED</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga4afb8830e0197ec11f6beb8140210a88ac2110b62e8233f66ccecd240e8d256a8">SPI_CALLBACK_BUFFER_TRANSCEIVED</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga4afb8830e0197ec11f6beb8140210a88a3c76f7df3c189cd31938fcf438427051">SPI_CALLBACK_ERROR</a>, 
<br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga4afb8830e0197ec11f6beb8140210a88a75545a7657914031640e2890220ea2ea">SPI_CALLBACK_SLAVE_TRANSMISSION_COMPLETE</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga4afb8830e0197ec11f6beb8140210a88a5941b69aff1bf66f116be84ddf1c1218">SPI_CALLBACK_N</a>
<br />
 }</td></tr>
<tr class="memdesc:ga4afb8830e0197ec11f6beb8140210a88"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI Callback enum.  <a href="group__asfdoc__sam0__sercom__spi__group.html#ga4afb8830e0197ec11f6beb8140210a88">More...</a><br /></td></tr>
<tr class="separator:ga4afb8830e0197ec11f6beb8140210a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3790f767d410bc7d70fe0772fe7044f7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga3790f767d410bc7d70fe0772fe7044f7">_spi_direction</a> { <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga3790f767d410bc7d70fe0772fe7044f7a103cc0246cfe23a4bdbd9919691bab19">SPI_DIRECTION_READ</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga3790f767d410bc7d70fe0772fe7044f7a58378c769c218216a742f064d20afbc5">SPI_DIRECTION_WRITE</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga3790f767d410bc7d70fe0772fe7044f7aa7d6441909cdfbb860d18b6b7d78fcc0">SPI_DIRECTION_BOTH</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga3790f767d410bc7d70fe0772fe7044f7aab6b2f188e1dc97b2024138ef1a45ad5">SPI_DIRECTION_IDLE</a>
 }</td></tr>
<tr class="separator:ga3790f767d410bc7d70fe0772fe7044f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16bab5d19c43ffb25c0d3f1e071813de"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga16bab5d19c43ffb25c0d3f1e071813de">spi_interrupt_flag</a> { <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga16bab5d19c43ffb25c0d3f1e071813deab47cccbc2e81d8af9d6c1fd777a95762">SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY</a> = SERCOM_SPI_INTFLAG_DRE, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga16bab5d19c43ffb25c0d3f1e071813deacc9db35e4654be2e4bd06d2a10fb3837">SPI_INTERRUPT_FLAG_TX_COMPLETE</a> = SERCOM_SPI_INTFLAG_TXC, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga16bab5d19c43ffb25c0d3f1e071813deabc7fa74e9f37b6aa492ca9889e7d8a92">SPI_INTERRUPT_FLAG_RX_COMPLETE</a> = SERCOM_SPI_INTFLAG_RXC
 }</td></tr>
<tr class="memdesc:ga16bab5d19c43ffb25c0d3f1e071813de"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI Interrupt Flags.  <a href="group__asfdoc__sam0__sercom__spi__group.html#ga16bab5d19c43ffb25c0d3f1e071813de">More...</a><br /></td></tr>
<tr class="separator:ga16bab5d19c43ffb25c0d3f1e071813de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c30fdfffba6be76b4044ccb17b218e5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a> { <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga9c30fdfffba6be76b4044ccb17b218e5addcbccd52e926858945de2e140199027">SPI_TRANSFER_MODE_0</a> = 0, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga9c30fdfffba6be76b4044ccb17b218e5aa55ca25e3c49ff34464adc654d14cfd5">SPI_TRANSFER_MODE_1</a> = SERCOM_SPI_CTRLA_CPHA, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga9c30fdfffba6be76b4044ccb17b218e5a29f104b5325a068ab32e652e21a1ec95">SPI_TRANSFER_MODE_2</a> = SERCOM_SPI_CTRLA_CPOL, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga9c30fdfffba6be76b4044ccb17b218e5a98dfa4850997601437f5183699d9e63c">SPI_TRANSFER_MODE_3</a> = SERCOM_SPI_CTRLA_CPHA | SERCOM_SPI_CTRLA_CPOL
 }</td></tr>
<tr class="memdesc:ga9c30fdfffba6be76b4044ccb17b218e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI transfer modes enum.  <a href="group__asfdoc__sam0__sercom__spi__group.html#ga9c30fdfffba6be76b4044ccb17b218e5">More...</a><br /></td></tr>
<tr class="separator:ga9c30fdfffba6be76b4044ccb17b218e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4598fb059ff90fccf8c9fa5b421f1bda"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga4598fb059ff90fccf8c9fa5b421f1bda">spi_frame_format</a> { <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga4598fb059ff90fccf8c9fa5b421f1bdaa9dbfeaf1014b44745b56ceda7e0d62d7">SPI_FRAME_FORMAT_SPI_FRAME</a> = SERCOM_SPI_CTRLA_FORM(0), 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga4598fb059ff90fccf8c9fa5b421f1bdaaba876059c4eb058d0988262d9df8e090">SPI_FRAME_FORMAT_SPI_FRAME_ADDR</a> = SERCOM_SPI_CTRLA_FORM(2)
 }</td></tr>
<tr class="memdesc:ga4598fb059ff90fccf8c9fa5b421f1bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI frame format enum.  <a href="group__asfdoc__sam0__sercom__spi__group.html#ga4598fb059ff90fccf8c9fa5b421f1bda">More...</a><br /></td></tr>
<tr class="separator:ga4598fb059ff90fccf8c9fa5b421f1bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga420e19efe4a923eb9ab6dc619a23c370"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga420e19efe4a923eb9ab6dc619a23c370">spi_signal_mux_setting</a> { <br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370a3cdcdd92d89e38733d77ac89f1a2ddd2">SPI_SIGNAL_MUX_SETTING_A</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370a6436816e953e9435937dadd832022e23">SPI_SIGNAL_MUX_SETTING_B</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370aedcff238d013e3a51eb6580ca3df64d1">SPI_SIGNAL_MUX_SETTING_C</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370a157acefdb388019c788d616f5225deda">SPI_SIGNAL_MUX_SETTING_D</a>, 
<br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370a7234b3f4e0aa7fe723cc85edabea9816">SPI_SIGNAL_MUX_SETTING_E</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370a578bd6b0685f742bf51e9c2a395c3ea2">SPI_SIGNAL_MUX_SETTING_F</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370ad9b9f4b431a3ac65423f57a96cac3bb9">SPI_SIGNAL_MUX_SETTING_G</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370a63225e36d738e0cc05c08a58c7a901bd">SPI_SIGNAL_MUX_SETTING_H</a>, 
<br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370ad421b8125db3d485b14470501b98066c">SPI_SIGNAL_MUX_SETTING_I</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370acc5588ae2498b0550997f6d647b19eda">SPI_SIGNAL_MUX_SETTING_J</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370aa01984d81ef8cef6c34c03f27bfbd406">SPI_SIGNAL_MUX_SETTING_K</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370a79fb82aa500712404307189ade71948f">SPI_SIGNAL_MUX_SETTING_L</a>, 
<br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370a6eba5168c427ef781eee612c99c2e7f6">SPI_SIGNAL_MUX_SETTING_M</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370a90871c4e6ee8f90df87ce0d851c1d2a1">SPI_SIGNAL_MUX_SETTING_N</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370a34fc3e98645ee794eb240b84e24c2966">SPI_SIGNAL_MUX_SETTING_O</a>, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga420e19efe4a923eb9ab6dc619a23c370aca300e01409474db47004e90d93c3fb3">SPI_SIGNAL_MUX_SETTING_P</a>
<br />
 }</td></tr>
<tr class="memdesc:ga420e19efe4a923eb9ab6dc619a23c370"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI signal MUX settings.  <a href="group__asfdoc__sam0__sercom__spi__group.html#ga420e19efe4a923eb9ab6dc619a23c370">More...</a><br /></td></tr>
<tr class="separator:ga420e19efe4a923eb9ab6dc619a23c370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30bf0ce7e5f944a5d3a42d90f0ebf617"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga30bf0ce7e5f944a5d3a42d90f0ebf617">spi_addr_mode</a> { <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga30bf0ce7e5f944a5d3a42d90f0ebf617a0031e737207555ff4de8c3f1c4cd51c7">SPI_ADDR_MODE_MASK</a> = SERCOM_SPI_CTRLB_AMODE(0), 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga30bf0ce7e5f944a5d3a42d90f0ebf617a1515f491a88330b601198c1792fda41a">SPI_ADDR_MODE_UNIQUE</a> = SERCOM_SPI_CTRLB_AMODE(1), 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga30bf0ce7e5f944a5d3a42d90f0ebf617a4205716bda98deed62a4c6d5c8ec9944">SPI_ADDR_MODE_RANGE</a> = SERCOM_SPI_CTRLB_AMODE(2)
 }</td></tr>
<tr class="memdesc:ga30bf0ce7e5f944a5d3a42d90f0ebf617"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI address modes enum.  <a href="group__asfdoc__sam0__sercom__spi__group.html#ga30bf0ce7e5f944a5d3a42d90f0ebf617">More...</a><br /></td></tr>
<tr class="separator:ga30bf0ce7e5f944a5d3a42d90f0ebf617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78c1313670220bedfecdb138d4c27903"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga78c1313670220bedfecdb138d4c27903">spi_mode</a> { <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga78c1313670220bedfecdb138d4c27903ae68a8adf6e5b67a7bdbe9526b15dae99">SPI_MODE_MASTER</a> = 1, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga78c1313670220bedfecdb138d4c27903ad1131ed33ad43ab3f667070b04454439">SPI_MODE_SLAVE</a> = 0
 }</td></tr>
<tr class="memdesc:ga78c1313670220bedfecdb138d4c27903"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI modes enum.  <a href="group__asfdoc__sam0__sercom__spi__group.html#ga78c1313670220bedfecdb138d4c27903">More...</a><br /></td></tr>
<tr class="separator:ga78c1313670220bedfecdb138d4c27903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa69dbc0601cb5b1e2681400598a4b2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a> { <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ggabaa69dbc0601cb5b1e2681400598a4b2ab016ca9032d6e9418d834514cc95b7d3">SPI_DATA_ORDER_LSB</a> = SERCOM_SPI_CTRLA_DORD, 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ggabaa69dbc0601cb5b1e2681400598a4b2a7eb5ed4b7d6f993acd7d09a5d8db3687">SPI_DATA_ORDER_MSB</a> = 0
 }</td></tr>
<tr class="memdesc:gabaa69dbc0601cb5b1e2681400598a4b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI data order enum.  <a href="group__asfdoc__sam0__sercom__spi__group.html#gabaa69dbc0601cb5b1e2681400598a4b2">More...</a><br /></td></tr>
<tr class="separator:gabaa69dbc0601cb5b1e2681400598a4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79e8becd0bcea19b99e7eb7fe8a9d6b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga79e8becd0bcea19b99e7eb7fe8a9d6b7">spi_character_size</a> { <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga79e8becd0bcea19b99e7eb7fe8a9d6b7a66283e49623ad09896942662b8221de6">SPI_CHARACTER_SIZE_8BIT</a> = SERCOM_SPI_CTRLB_CHSIZE(0), 
<a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gga79e8becd0bcea19b99e7eb7fe8a9d6b7ab70647e252f3251aac0100b56c3d30af">SPI_CHARACTER_SIZE_9BIT</a> = SERCOM_SPI_CTRLB_CHSIZE(1)
 }</td></tr>
<tr class="memdesc:ga79e8becd0bcea19b99e7eb7fe8a9d6b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">SPI character size enum.  <a href="group__asfdoc__sam0__sercom__spi__group.html#ga79e8becd0bcea19b99e7eb7fe8a9d6b7">More...</a><br /></td></tr>
<tr class="separator:ga79e8becd0bcea19b99e7eb7fe8a9d6b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga71091c8fcde0d526329e04f8c7b24efc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga71091c8fcde0d526329e04f8c7b24efc">_spi_interrupt_handler</a> (uint8_t instance)</td></tr>
<tr class="separator:ga71091c8fcde0d526329e04f8c7b24efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bc86fe61f20b414ac3ca1a74c28dd28"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga6bc86fe61f20b414ac3ca1a74c28dd28">spi_set_baudrate</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module, uint32_t baudrate)</td></tr>
<tr class="memdesc:ga6bc86fe61f20b414ac3ca1a74c28dd28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the baudrate of the SPI module.  <a href="#ga6bc86fe61f20b414ac3ca1a74c28dd28">More...</a><br /></td></tr>
<tr class="separator:ga6bc86fe61f20b414ac3ca1a74c28dd28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Driver Initialization and Configuration</h2></td></tr>
<tr class="memitem:ga83b840fe8c91173bfe54a13787c262e6"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga83b840fe8c91173bfe54a13787c262e6">spi_init</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module, <a class="el" href="union_sercom.html">Sercom</a> *const hw, const struct <a class="el" href="structspi__config.html">spi_config</a> *const config)</td></tr>
<tr class="memdesc:ga83b840fe8c91173bfe54a13787c262e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the SERCOM SPI module.  <a href="#ga83b840fe8c91173bfe54a13787c262e6">More...</a><br /></td></tr>
<tr class="separator:ga83b840fe8c91173bfe54a13787c262e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Enable/Disable</h2></td></tr>
<tr class="memitem:ga65c764f92ed46f0d4845232bd4b241bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga65c764f92ed46f0d4845232bd4b241bc">spi_reset</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module)</td></tr>
<tr class="memdesc:ga65c764f92ed46f0d4845232bd4b241bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the SPI module.  <a href="#ga65c764f92ed46f0d4845232bd4b241bc">More...</a><br /></td></tr>
<tr class="separator:ga65c764f92ed46f0d4845232bd4b241bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Read/Write</h2></td></tr>
<tr class="memitem:gae217dcf01506d2ad9ea554a14e57245f"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gae217dcf01506d2ad9ea554a14e57245f">spi_write_buffer_wait</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module, const uint8_t *tx_data, uint16_t length)</td></tr>
<tr class="memdesc:gae217dcf01506d2ad9ea554a14e57245f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a buffer of <code>length</code> SPI characters.  <a href="#gae217dcf01506d2ad9ea554a14e57245f">More...</a><br /></td></tr>
<tr class="separator:gae217dcf01506d2ad9ea554a14e57245f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cdeea24cfa24ab872044c6fa1ae893f"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga7cdeea24cfa24ab872044c6fa1ae893f">spi_read_buffer_wait</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module, uint8_t *rx_data, uint16_t length, uint16_t dummy)</td></tr>
<tr class="memdesc:ga7cdeea24cfa24ab872044c6fa1ae893f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads buffer of <code>length</code> SPI characters.  <a href="#ga7cdeea24cfa24ab872044c6fa1ae893f">More...</a><br /></td></tr>
<tr class="separator:ga7cdeea24cfa24ab872044c6fa1ae893f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3eb1d72360e67b6fef7574320a5919e6"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga3eb1d72360e67b6fef7574320a5919e6">spi_transceive_wait</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module, uint16_t tx_data, uint16_t *rx_data)</td></tr>
<tr class="memdesc:ga3eb1d72360e67b6fef7574320a5919e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends and reads a single SPI character.  <a href="#ga3eb1d72360e67b6fef7574320a5919e6">More...</a><br /></td></tr>
<tr class="separator:ga3eb1d72360e67b6fef7574320a5919e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad784fee69a16acef8e4e3b8be4a4d61d"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gad784fee69a16acef8e4e3b8be4a4d61d">spi_transceive_buffer_wait</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module, uint8_t *tx_data, uint8_t *rx_data, uint16_t length)</td></tr>
<tr class="memdesc:gad784fee69a16acef8e4e3b8be4a4d61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends and receives a buffer of <code>length</code> SPI characters.  <a href="#gad784fee69a16acef8e4e3b8be4a4d61d">More...</a><br /></td></tr>
<tr class="separator:gad784fee69a16acef8e4e3b8be4a4d61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff6f75d83ec5251e6d1d42830b8af05f"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gaff6f75d83ec5251e6d1d42830b8af05f">spi_select_slave</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module, struct <a class="el" href="structspi__slave__inst.html">spi_slave_inst</a> *const slave, <a class="el" href="group__group__sam0__utils.html#ga97a80ca1602ebf2303258971a2c938e2">bool</a> select)</td></tr>
<tr class="memdesc:gaff6f75d83ec5251e6d1d42830b8af05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects slave device.  <a href="#gaff6f75d83ec5251e6d1d42830b8af05f">More...</a><br /></td></tr>
<tr class="separator:gaff6f75d83ec5251e6d1d42830b8af05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Callback Management</h2></td></tr>
<tr class="memitem:ga9736ace2b57a6d45d3fb820aae552a48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga9736ace2b57a6d45d3fb820aae552a48">spi_register_callback</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module, <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga88d771c03a254735de0053be3fa513ca">spi_callback_t</a> callback_func, enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga4afb8830e0197ec11f6beb8140210a88">spi_callback</a> callback_type)</td></tr>
<tr class="memdesc:ga9736ace2b57a6d45d3fb820aae552a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a SPI callback function.  <a href="#ga9736ace2b57a6d45d3fb820aae552a48">More...</a><br /></td></tr>
<tr class="separator:ga9736ace2b57a6d45d3fb820aae552a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7df7ed6a6a9d6a5e1338ceaa0d5f07b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga7df7ed6a6a9d6a5e1338ceaa0d5f07b2">spi_unregister_callback</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *module, enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga4afb8830e0197ec11f6beb8140210a88">spi_callback</a> callback_type)</td></tr>
<tr class="memdesc:ga7df7ed6a6a9d6a5e1338ceaa0d5f07b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters a SPI callback function.  <a href="#ga7df7ed6a6a9d6a5e1338ceaa0d5f07b2">More...</a><br /></td></tr>
<tr class="separator:ga7df7ed6a6a9d6a5e1338ceaa0d5f07b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Writing and Reading</h2></td></tr>
<tr class="memitem:ga7a7ddeab7e3ed355e13366ed635ff152"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga7a7ddeab7e3ed355e13366ed635ff152">spi_write_buffer_job</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module, uint8_t *tx_data, uint16_t length)</td></tr>
<tr class="memdesc:ga7a7ddeab7e3ed355e13366ed635ff152"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous buffer write.  <a href="#ga7a7ddeab7e3ed355e13366ed635ff152">More...</a><br /></td></tr>
<tr class="separator:ga7a7ddeab7e3ed355e13366ed635ff152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5022683cb35d827578c26cf7689ae61"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gac5022683cb35d827578c26cf7689ae61">spi_read_buffer_job</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module, uint8_t *rx_data, uint16_t length, uint16_t dummy)</td></tr>
<tr class="memdesc:gac5022683cb35d827578c26cf7689ae61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous buffer read.  <a href="#gac5022683cb35d827578c26cf7689ae61">More...</a><br /></td></tr>
<tr class="separator:gac5022683cb35d827578c26cf7689ae61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba6ac49efcf4b51fa8131d4a07071967"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gaba6ac49efcf4b51fa8131d4a07071967">spi_transceive_buffer_job</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module, uint8_t *tx_data, uint8_t *rx_data, uint16_t length)</td></tr>
<tr class="memdesc:gaba6ac49efcf4b51fa8131d4a07071967"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronous buffer write and read.  <a href="#gaba6ac49efcf4b51fa8131d4a07071967">More...</a><br /></td></tr>
<tr class="separator:gaba6ac49efcf4b51fa8131d4a07071967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74d13a9fe3203f121664b864f68c94fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga74d13a9fe3203f121664b864f68c94fd">spi_abort_job</a> (struct <a class="el" href="structspi__module.html">spi_module</a> *const module)</td></tr>
<tr class="memdesc:ga74d13a9fe3203f121664b864f68c94fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts an ongoing job.  <a href="#ga74d13a9fe3203f121664b864f68c94fd">More...</a><br /></td></tr>
<tr class="separator:ga74d13a9fe3203f121664b864f68c94fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This driver for Atmel&reg; | SMART ARM&reg;-based microcontrollers provides an interface for the configuration and management of the SERCOM module in its SPI mode to transfer SPI data frames. The following driver API modes are covered by this manual:</p>
<ul>
<li>Polled APIs</li>
</ul>
<p>The following peripheral is used by this module:</p><ul>
<li>SERCOM (Serial Communication Interface)</li>
</ul>
<p>The following devices can use this module:</p><ul>
<li>Atmel | SMART SAM D20/D21</li>
<li>Atmel | SMART SAM R21</li>
<li>Atmel | SMART SAM D09/D10/D11</li>
<li>Atmel | SMART SAM L21/L22</li>
<li>Atmel | SMART SAM DA1</li>
<li>Atmel | SMART SAM C20/C21</li>
<li>Atmel | SMART SAM HA1</li>
<li>Atmel | SMART SAM R30</li>
</ul>
<p>The outline of this documentation is as follows:</p><ul>
<li><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#asfdoc_sam0_sercom_spi_prerequisites">Prerequisites</a></li>
<li><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#asfdoc_sam0_sercom_spi_module_overview">Module Overview</a></li>
<li><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#asfdoc_sam0_sercom_spi_special_considerations">Special Considerations</a></li>
<li><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#asfdoc_sam0_sercom_spi_extra_info">Extra Information</a></li>
<li><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#asfdoc_sam0_sercom_spi_examples">Examples</a></li>
<li><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#asfdoc_sam0_sercom_spi_api_overview">API Overview</a></li>
</ul>
<h1><a class="anchor" id="asfdoc_sam0_sercom_spi_prerequisites"></a>
Prerequisites</h1>
<p>There are no prerequisites.</p>
<h1><a class="anchor" id="asfdoc_sam0_sercom_spi_module_overview"></a>
Module Overview</h1>
<p>The Serial Peripheral Interface (SPI) is a high-speed synchronous data transfer interface using three or four pins. It allows fast communication between a master device and one or more peripheral devices.</p>
<p>A device connected to the bus must act as a master or a slave. The master initiates and controls all data transactions. The SPI master initiates a communication cycle by pulling low the Slave Select (SS) pin of the desired slave. The Slave Select pin is active low. Master and slave prepare data to be sent in their respective shift registers, and the master generates the required clock pulses on the SCK line to interchange data. Data is always shifted from master to slave on the Master Out - Slave In (MOSI) line, and from slave to master on the Master In - Slave Out (MISO) line. After each data transfer, the master can synchronize to the slave by pulling the SS line high.</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_spi_module_features"></a>
Driver Feature Macro Definition</h2>
<table class="doxtable">
<tr>
<th>Driver feature macro </th><th>Supported devices  </th></tr>
<tr>
<td>FEATURE_SPI_SLAVE_SELECT_LOW_DETECT </td><td>SAM D21/R21/D10/D11/L21/L22/DA1/C20/C21/R30  </td></tr>
<tr>
<td>FEATURE_SPI_HARDWARE_SLAVE_SELECT </td><td>SAM D21/R21/D10/D11/L21/L22/DA1/C20/C21/R30  </td></tr>
<tr>
<td>FEATURE_SPI_ERROR_INTERRUPT </td><td>SAM D21/R21/D10/D11/L21/L22/DA1/C20/C21/R30  </td></tr>
<tr>
<td>FEATURE_SPI_SYNC_SCHEME_VERSION_2 </td><td>SAM D21/R21/D10/D11/L21/L22/DA1/C20/C21/R30  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The specific features are only available in the driver when the selected device supports those features.</dd></dl>
<h2><a class="anchor" id="asfdoc_sam0_sercom_spi_bus"></a>
SPI Bus Connection</h2>
<p>In <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#asfdoc_sam0_spi_connection_example">the figure below</a>, the connection between one master and one slave is shown.</p>
<p><a class="anchor" id="asfdoc_sam0_spi_connection_example"></a></p><div class="dotgraph">
</div>
<p>The different lines are as follows:</p><ul>
<li><b>MISO</b> Master Input Slave Output. The line where the data is shifted out from the slave and into the master.</li>
<li><b>MOSI</b> Master Output Slave Input. The line where the data is shifted out from the master and into the slave.</li>
<li><b>SCK</b> Serial Clock. Generated by the master device.</li>
<li><b>SS</b> Slave Select. To initiate a transaction, the master must pull this line low.</li>
</ul>
<p>If the bus consists of several SPI slaves, they can be connected in parallel and the SPI master can use general I/O pins to control separate SS lines to each slave on the bus.</p>
<p>It is also possible to connect all slaves in series. In this configuration, a common SS is provided to <code>N</code> slaves, enabling them simultaneously. The MISO from the <code>N-1</code> slaves is connected to the MOSI on the next slave. The <code>N<sup>th</sup></code> slave connects its MISO back to the master. For a complete transaction, the master must shift <code>N+1</code> characters.</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_spi_chsize"></a>
SPI Character Size</h2>
<p>The SPI character size is configurable to eight or nine bits.</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_spi_master_mode"></a>
Master Mode</h2>
<p>When configured as a master, the SS pin will be configured as an output.</p>
<h3><a class="anchor" id="asfdoc_sam0_sercom_spi_master_mode_data_transfer"></a>
Data Transfer</h3>
<p>Writing a character will start the SPI clock generator, and the character is transferred to the shift register when the shift register is empty. Once this is done, a new character can be written. As each character is shifted out from the master, a character is shifted in from the slave. If the receiver is enabled, the data is moved to the receive buffer at the completion of the frame and can be read.</p>
<h2><a class="anchor" id="asfdoc_sam0_sercom_spi_slave_mode"></a>
Slave Mode</h2>
<p>When configured as a slave, the SPI interface will remain inactive with MISO tri-stated as long as the SS pin is driven high.</p>
<h3><a class="anchor" id="asfdoc_sam0_sercom_spi_slave_mode_data_transfer_slave"></a>
Data Transfer</h3>
<p>The data register can be updated at any time. As the SPI slave shift register is clocked by SCK, a minimum of three SCK cycles are needed from the time new data is written, until the character is ready to be shifted out. If the shift register has not been loaded with data, the current contents will be transmitted.</p>
<p>If constant transmission of data is needed in SPI slave mode, the system clock should be faster than SCK. If the receiver is enabled, the received character can be read from the receive buffer. When SS line is driven high, the slave will not receive any additional data.</p>
<h3><a class="anchor" id="asfdoc_sam0_sercom_spi_slave_mode_addr_recognition"></a>
Address Recognition</h3>
<p>When the SPI slave is configured with address recognition, the first character in a transaction is checked for an address match. If there is a match, the MISO output is enabled and the transaction is processed. If the address does not match, the complete transaction is ignored.</p>
<p>If the device is asleep, it can be woken up by an address match in order to process the transaction.</p>
<dl class="section note"><dt>Note</dt><dd>In master mode, an address packet is written by the <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gaff6f75d83ec5251e6d1d42830b8af05f">spi_select_slave</a> function if the address_enabled configuration is set in the <a class="el" href="structspi__slave__inst__config.html">spi_slave_inst_config</a> struct.</dd></dl>
<h2><a class="anchor" id="asfdoc_sam0_sercom_spi_data_modes"></a>
Data Modes</h2>
<p>There are four combinations of SCK phase and polarity with respect to serial data. <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#asfdoc_sam0_spi_mode_table">The table below</a> shows the clock polarity (CPOL) and clock phase (CPHA) in the different modes. <em>Leading edge</em> is the first clock edge in a clock cycle and <em>trailing edge</em> is the last clock edge in a clock cycle.</p>
<p><a class="anchor" id="asfdoc_sam0_spi_mode_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>SPI Data Modes</caption>
<tr>
<th>Mode </th><th>CPOL </th><th>CPHA </th><th>Leading Edge </th><th>Trailing Edge  </th></tr>
<tr>
<td>0  </td><td>0  </td><td>0  </td><td>Rising, Sample  </td><td>Falling, Setup   </td></tr>
<tr>
<td>1  </td><td>0  </td><td>1  </td><td>Rising, Setup  </td><td>Falling, Sample   </td></tr>
<tr>
<td>2  </td><td>1  </td><td>0  </td><td>Falling, Sample  </td><td>Rising, Setup   </td></tr>
<tr>
<td>3  </td><td>1  </td><td>1  </td><td>Falling, Setup  </td><td>Rising, Sample   </td></tr>
</table>
<h2><a class="anchor" id="asfdoc_sam0_sercom_spi_pads"></a>
SERCOM Pads</h2>
<p>The SERCOM pads are automatically configured as seen in <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#asfdoc_sam0_spi_sercom_pad_table">the table below</a>. If the receiver is disabled, the data input (MISO for master, MOSI for slave) can be used for other purposes.</p>
<p>In master mode, the SS pin(s) must be configured using the <a class="el" href="structspi__slave__inst.html">spi_slave_inst</a> struct.</p>
<p><a class="anchor" id="asfdoc_sam0_spi_sercom_pad_table"></a></p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>SERCOM SPI Pad Usages</caption>
<tr>
<th>Pin  </th><th>Master SPI  </th><th>Slave SPI   </th></tr>
<tr>
<td>MOSI  </td><td>Output  </td><td>Input   </td></tr>
<tr>
<td>MISO  </td><td>Input  </td><td>Output   </td></tr>
<tr>
<td>SCK  </td><td>Output  </td><td>Input   </td></tr>
<tr>
<td>SS  </td><td>User defined output enable  </td><td>Input   </td></tr>
</table>
<h2><a class="anchor" id="asfdoc_sam0_sercom_spi_sleep_modes"></a>
Operation in Sleep Modes</h2>
<p>The SPI module can operate in all sleep modes by setting the run_in_standby option in the <a class="el" href="structspi__config.html">spi_config</a> struct. The operation in slave and master mode is shown in the table below. </p><table class="doxtable">
<tr>
<th>run_in_standby  </th><th>Slave  </th><th>Master   </th></tr>
<tr>
<td>false  </td><td>Disabled, all reception is dropped  </td><td>GCLK is disabled when master is idle, wake on transmit complete   </td></tr>
<tr>
<td>true  </td><td>Wake on reception  </td><td>GCLK is enabled while in sleep modes, wake on all interrupts   </td></tr>
</table>
<h2><a class="anchor" id="asfdoc_sam0_sercom_spi_clock_generation"></a>
Clock Generation</h2>
<p>In SPI master mode, the clock (SCK) is generated internally using the SERCOM baudrate generator. In SPI slave mode, the clock is provided by an external master on the SCK pin. This clock is used to directly clock the SPI shift register.</p>
<h1><a class="anchor" id="asfdoc_sam0_sercom_spi_special_considerations"></a>
Special Considerations</h1>
<h2><a class="anchor" id="pin_mux"></a>
pinmux Settings</h2>
<p>The pin MUX settings must be configured properly, as not all settings can be used in different modes of operation.</p>
<h1><a class="anchor" id="asfdoc_sam0_sercom_spi_extra_info"></a>
Extra Information</h1>
<p>For extra information, see <a class="el" href="asfdoc_sam0_sercom_spi_extra.html">Extra Information for SERCOM SPI Driver</a>. This includes:</p><ul>
<li><a class="el" href="asfdoc_sam0_sercom_spi_extra.html#asfdoc_sam0_sercom_spi_extra_acronyms">Acronyms</a></li>
<li><a class="el" href="asfdoc_sam0_sercom_spi_extra.html#asfdoc_sam0_sercom_spi_extra_dependencies">Dependencies</a></li>
<li><a class="el" href="asfdoc_sam0_sercom_spi_extra.html#asfdoc_sam0_sercom_spi_extra_workarounds">Workarounds Implemented by Driver</a></li>
<li><a class="el" href="asfdoc_sam0_sercom_spi_extra.html#asfdoc_sam0_sercom_spi_extra_history">Module History</a></li>
</ul>
<h1><a class="anchor" id="asfdoc_sam0_sercom_spi_examples"></a>
Examples</h1>
<p>For a list of examples related to this driver, see <a class="el" href="asfdoc_sam0_sercom_spi_exqsg.html">Examples for SERCOM SPI Driver</a>.</p>
<h1><a class="anchor" id="asfdoc_sam0_sercom_spi_api_overview"></a>
API Overview</h1>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gae7bc85650aed61f97fe3d5df9b430456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7bc85650aed61f97fe3d5df9b430456">&#9670;&nbsp;</a></span>PINMUX_DEFAULT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PINMUX_DEFAULT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default pinmux. </p>

</div>
</div>
<a id="gaffde9ff712058ef836127e1f3368889e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffde9ff712058ef836127e1f3368889e">&#9670;&nbsp;</a></span>PINMUX_UNUSED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PINMUX_UNUSED&#160;&#160;&#160;0xFFFFFFFF</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unused pinmux. </p>

</div>
</div>
<a id="ga0131f2774f4e3dd71567400683b60405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0131f2774f4e3dd71567400683b60405">&#9670;&nbsp;</a></span>SPI_TIMEOUT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define SPI_TIMEOUT&#160;&#160;&#160;10000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SPI timeout value. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga88d771c03a254735de0053be3fa513ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88d771c03a254735de0053be3fa513ca">&#9670;&nbsp;</a></span>spi_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* spi_callback_t) (struct <a class="el" href="structspi__module.html">spi_module</a> *const module)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the callback functions </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3790f767d410bc7d70fe0772fe7044f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3790f767d410bc7d70fe0772fe7044f7">&#9670;&nbsp;</a></span>_spi_direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga3790f767d410bc7d70fe0772fe7044f7">_spi_direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga3790f767d410bc7d70fe0772fe7044f7a103cc0246cfe23a4bdbd9919691bab19"></a>SPI_DIRECTION_READ&#160;</td><td class="fielddoc"><p>Transfer direction is read </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3790f767d410bc7d70fe0772fe7044f7a58378c769c218216a742f064d20afbc5"></a>SPI_DIRECTION_WRITE&#160;</td><td class="fielddoc"><p>Transfer direction is write </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3790f767d410bc7d70fe0772fe7044f7aa7d6441909cdfbb860d18b6b7d78fcc0"></a>SPI_DIRECTION_BOTH&#160;</td><td class="fielddoc"><p>Transfer direction is read and write </p>
</td></tr>
<tr><td class="fieldname"><a id="gga3790f767d410bc7d70fe0772fe7044f7aab6b2f188e1dc97b2024138ef1a45ad5"></a>SPI_DIRECTION_IDLE&#160;</td><td class="fielddoc"><p>No transfer </p>
</td></tr>
</table>

</div>
</div>
<a id="ga30bf0ce7e5f944a5d3a42d90f0ebf617"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30bf0ce7e5f944a5d3a42d90f0ebf617">&#9670;&nbsp;</a></span>spi_addr_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga30bf0ce7e5f944a5d3a42d90f0ebf617">spi_addr_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI address modes enum. </p>
<p>For slave mode when using the SPI frame with address format. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga30bf0ce7e5f944a5d3a42d90f0ebf617a0031e737207555ff4de8c3f1c4cd51c7"></a>SPI_ADDR_MODE_MASK&#160;</td><td class="fielddoc"><p><code>address_mask</code> in the <a class="el" href="structspi__config.html">spi_config</a> struct is used as a mask to the register </p>
</td></tr>
<tr><td class="fieldname"><a id="gga30bf0ce7e5f944a5d3a42d90f0ebf617a1515f491a88330b601198c1792fda41a"></a>SPI_ADDR_MODE_UNIQUE&#160;</td><td class="fielddoc"><p>The slave responds to the two unique addresses in <code>address</code> and <code>address_mask</code> in the <a class="el" href="structspi__config.html">spi_config</a> struct </p>
</td></tr>
<tr><td class="fieldname"><a id="gga30bf0ce7e5f944a5d3a42d90f0ebf617a4205716bda98deed62a4c6d5c8ec9944"></a>SPI_ADDR_MODE_RANGE&#160;</td><td class="fielddoc"><p>The slave responds to the range of addresses between and including <code>address</code> and <code>address_mask</code> in the <a class="el" href="structspi__config.html">spi_config</a> struct </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4afb8830e0197ec11f6beb8140210a88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4afb8830e0197ec11f6beb8140210a88">&#9670;&nbsp;</a></span>spi_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga4afb8830e0197ec11f6beb8140210a88">spi_callback</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI Callback enum. </p>
<p>Callbacks for SPI callback driver.</p>
<dl class="section note"><dt>Note</dt><dd>For slave mode, these callbacks will be called when a transaction is ended by the master pulling Slave Select high. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4afb8830e0197ec11f6beb8140210a88a457c19f75d284d1664cc38b0f1e1eb81"></a>SPI_CALLBACK_BUFFER_TRANSMITTED&#160;</td><td class="fielddoc"><p>Callback for buffer transmitted </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4afb8830e0197ec11f6beb8140210a88a7da8cc036860fc86ef36aeeffe9088ec"></a>SPI_CALLBACK_BUFFER_RECEIVED&#160;</td><td class="fielddoc"><p>Callback for buffer received </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4afb8830e0197ec11f6beb8140210a88ac2110b62e8233f66ccecd240e8d256a8"></a>SPI_CALLBACK_BUFFER_TRANSCEIVED&#160;</td><td class="fielddoc"><p>Callback for buffers transceived </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4afb8830e0197ec11f6beb8140210a88a3c76f7df3c189cd31938fcf438427051"></a>SPI_CALLBACK_ERROR&#160;</td><td class="fielddoc"><p>Callback for error </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4afb8830e0197ec11f6beb8140210a88a75545a7657914031640e2890220ea2ea"></a>SPI_CALLBACK_SLAVE_TRANSMISSION_COMPLETE&#160;</td><td class="fielddoc"><p>Callback for transmission ended by master before the entire buffer was read or written from slave </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4afb8830e0197ec11f6beb8140210a88a5941b69aff1bf66f116be84ddf1c1218"></a>SPI_CALLBACK_N&#160;</td><td class="fielddoc"><p>Number of available callbacks </p>
</td></tr>
</table>

</div>
</div>
<a id="ga79e8becd0bcea19b99e7eb7fe8a9d6b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79e8becd0bcea19b99e7eb7fe8a9d6b7">&#9670;&nbsp;</a></span>spi_character_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga79e8becd0bcea19b99e7eb7fe8a9d6b7">spi_character_size</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI character size enum. </p>
<p>SPI character size. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga79e8becd0bcea19b99e7eb7fe8a9d6b7a66283e49623ad09896942662b8221de6"></a>SPI_CHARACTER_SIZE_8BIT&#160;</td><td class="fielddoc"><p>8-bit character </p>
</td></tr>
<tr><td class="fieldname"><a id="gga79e8becd0bcea19b99e7eb7fe8a9d6b7ab70647e252f3251aac0100b56c3d30af"></a>SPI_CHARACTER_SIZE_9BIT&#160;</td><td class="fielddoc"><p>9-bit character </p>
</td></tr>
</table>

</div>
</div>
<a id="gabaa69dbc0601cb5b1e2681400598a4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaa69dbc0601cb5b1e2681400598a4b2">&#9670;&nbsp;</a></span>spi_data_order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gabaa69dbc0601cb5b1e2681400598a4b2">spi_data_order</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI data order enum. </p>
<p>SPI data order. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggabaa69dbc0601cb5b1e2681400598a4b2ab016ca9032d6e9418d834514cc95b7d3"></a>SPI_DATA_ORDER_LSB&#160;</td><td class="fielddoc"><p>The LSB of the data is transmitted first </p>
</td></tr>
<tr><td class="fieldname"><a id="ggabaa69dbc0601cb5b1e2681400598a4b2a7eb5ed4b7d6f993acd7d09a5d8db3687"></a>SPI_DATA_ORDER_MSB&#160;</td><td class="fielddoc"><p>The MSB of the data is transmitted first </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4598fb059ff90fccf8c9fa5b421f1bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4598fb059ff90fccf8c9fa5b421f1bda">&#9670;&nbsp;</a></span>spi_frame_format</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga4598fb059ff90fccf8c9fa5b421f1bda">spi_frame_format</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI frame format enum. </p>
<p>Frame format for slave mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4598fb059ff90fccf8c9fa5b421f1bdaa9dbfeaf1014b44745b56ceda7e0d62d7"></a>SPI_FRAME_FORMAT_SPI_FRAME&#160;</td><td class="fielddoc"><p>SPI frame </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4598fb059ff90fccf8c9fa5b421f1bdaaba876059c4eb058d0988262d9df8e090"></a>SPI_FRAME_FORMAT_SPI_FRAME_ADDR&#160;</td><td class="fielddoc"><p>SPI frame with address </p>
</td></tr>
</table>

</div>
</div>
<a id="ga16bab5d19c43ffb25c0d3f1e071813de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16bab5d19c43ffb25c0d3f1e071813de">&#9670;&nbsp;</a></span>spi_interrupt_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga16bab5d19c43ffb25c0d3f1e071813de">spi_interrupt_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI Interrupt Flags. </p>
<p>Interrupt flags for the SPI module. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga16bab5d19c43ffb25c0d3f1e071813deab47cccbc2e81d8af9d6c1fd777a95762"></a>SPI_INTERRUPT_FLAG_DATA_REGISTER_EMPTY&#160;</td><td class="fielddoc"><p>This flag is set when the contents of the data register has been moved to the shift register and the data register is ready for new data </p>
</td></tr>
<tr><td class="fieldname"><a id="gga16bab5d19c43ffb25c0d3f1e071813deacc9db35e4654be2e4bd06d2a10fb3837"></a>SPI_INTERRUPT_FLAG_TX_COMPLETE&#160;</td><td class="fielddoc"><p>This flag is set when the contents of the shift register has been shifted out </p>
</td></tr>
<tr><td class="fieldname"><a id="gga16bab5d19c43ffb25c0d3f1e071813deabc7fa74e9f37b6aa492ca9889e7d8a92"></a>SPI_INTERRUPT_FLAG_RX_COMPLETE&#160;</td><td class="fielddoc"><p>This flag is set when data has been shifted into the data register </p>
</td></tr>
</table>

</div>
</div>
<a id="ga78c1313670220bedfecdb138d4c27903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78c1313670220bedfecdb138d4c27903">&#9670;&nbsp;</a></span>spi_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga78c1313670220bedfecdb138d4c27903">spi_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI modes enum. </p>
<p>SPI mode selection. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga78c1313670220bedfecdb138d4c27903ae68a8adf6e5b67a7bdbe9526b15dae99"></a>SPI_MODE_MASTER&#160;</td><td class="fielddoc"><p>Master mode </p>
</td></tr>
<tr><td class="fieldname"><a id="gga78c1313670220bedfecdb138d4c27903ad1131ed33ad43ab3f667070b04454439"></a>SPI_MODE_SLAVE&#160;</td><td class="fielddoc"><p>Slave mode </p>
</td></tr>
</table>

</div>
</div>
<a id="ga420e19efe4a923eb9ab6dc619a23c370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga420e19efe4a923eb9ab6dc619a23c370">&#9670;&nbsp;</a></span>spi_signal_mux_setting</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga420e19efe4a923eb9ab6dc619a23c370">spi_signal_mux_setting</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI signal MUX settings. </p>
<p>Set the functionality of the SERCOM pins. As not all combinations can be used in different modes of operation, proper combinations must be chosen according to the rest of the configuration.</p>
<dl class="section note"><dt>Note</dt><dd>In master operation: DI is MISO, DO is MOSI. In slave operation: DI is MOSI, DO is MISO.</dd></dl>
<p>See <a class="el" href="asfdoc_sam0_sercom_spi_mux_settings.html">MUX Settings</a> for a description of the various MUX setting options. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370a3cdcdd92d89e38733d77ac89f1a2ddd2"></a>SPI_SIGNAL_MUX_SETTING_A&#160;</td><td class="fielddoc"><p>SPI MUX combination A. DOPO: 0x0, DIPO: 0x0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370a6436816e953e9435937dadd832022e23"></a>SPI_SIGNAL_MUX_SETTING_B&#160;</td><td class="fielddoc"><p>SPI MUX combination B. DOPO: 0x0, DIPO: 0x1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370aedcff238d013e3a51eb6580ca3df64d1"></a>SPI_SIGNAL_MUX_SETTING_C&#160;</td><td class="fielddoc"><p>SPI MUX combination C. DOPO: 0x0, DIPO: 0x2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370a157acefdb388019c788d616f5225deda"></a>SPI_SIGNAL_MUX_SETTING_D&#160;</td><td class="fielddoc"><p>SPI MUX combination D. DOPO: 0x0, DIPO: 0x3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370a7234b3f4e0aa7fe723cc85edabea9816"></a>SPI_SIGNAL_MUX_SETTING_E&#160;</td><td class="fielddoc"><p>SPI MUX combination E. DOPO: 0x1, DIPO: 0x0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370a578bd6b0685f742bf51e9c2a395c3ea2"></a>SPI_SIGNAL_MUX_SETTING_F&#160;</td><td class="fielddoc"><p>SPI MUX combination F. DOPO: 0x1, DIPO: 0x1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370ad9b9f4b431a3ac65423f57a96cac3bb9"></a>SPI_SIGNAL_MUX_SETTING_G&#160;</td><td class="fielddoc"><p>SPI MUX combination G. DOPO: 0x1, DIPO: 0x2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370a63225e36d738e0cc05c08a58c7a901bd"></a>SPI_SIGNAL_MUX_SETTING_H&#160;</td><td class="fielddoc"><p>SPI MUX combination H. DOPO: 0x1, DIPO: 0x3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370ad421b8125db3d485b14470501b98066c"></a>SPI_SIGNAL_MUX_SETTING_I&#160;</td><td class="fielddoc"><p>SPI MUX combination I. DOPO: 0x2, DIPO: 0x0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370acc5588ae2498b0550997f6d647b19eda"></a>SPI_SIGNAL_MUX_SETTING_J&#160;</td><td class="fielddoc"><p>SPI MUX combination J. DOPO: 0x2, DIPO: 0x1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370aa01984d81ef8cef6c34c03f27bfbd406"></a>SPI_SIGNAL_MUX_SETTING_K&#160;</td><td class="fielddoc"><p>SPI MUX combination K. DOPO: 0x2, DIPO: 0x2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370a79fb82aa500712404307189ade71948f"></a>SPI_SIGNAL_MUX_SETTING_L&#160;</td><td class="fielddoc"><p>SPI MUX combination L. DOPO: 0x2, DIPO: 0x3 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370a6eba5168c427ef781eee612c99c2e7f6"></a>SPI_SIGNAL_MUX_SETTING_M&#160;</td><td class="fielddoc"><p>SPI MUX combination M. DOPO: 0x3, DIPO: 0x0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370a90871c4e6ee8f90df87ce0d851c1d2a1"></a>SPI_SIGNAL_MUX_SETTING_N&#160;</td><td class="fielddoc"><p>SPI MUX combination N. DOPO: 0x3, DIPO: 0x1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370a34fc3e98645ee794eb240b84e24c2966"></a>SPI_SIGNAL_MUX_SETTING_O&#160;</td><td class="fielddoc"><p>SPI MUX combination O. DOPO: 0x3, DIPO: 0x2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga420e19efe4a923eb9ab6dc619a23c370aca300e01409474db47004e90d93c3fb3"></a>SPI_SIGNAL_MUX_SETTING_P&#160;</td><td class="fielddoc"><p>SPI MUX combination P. DOPO: 0x3, DIPO: 0x3 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9c30fdfffba6be76b4044ccb17b218e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c30fdfffba6be76b4044ccb17b218e5">&#9670;&nbsp;</a></span>spi_transfer_mode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga9c30fdfffba6be76b4044ccb17b218e5">spi_transfer_mode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SPI transfer modes enum. </p>
<p>SPI transfer mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9c30fdfffba6be76b4044ccb17b218e5addcbccd52e926858945de2e140199027"></a>SPI_TRANSFER_MODE_0&#160;</td><td class="fielddoc"><p>Mode 0. Leading edge: rising, sample. Trailing edge: falling, setup </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9c30fdfffba6be76b4044ccb17b218e5aa55ca25e3c49ff34464adc654d14cfd5"></a>SPI_TRANSFER_MODE_1&#160;</td><td class="fielddoc"><p>Mode 1. Leading edge: rising, setup. Trailing edge: falling, sample </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9c30fdfffba6be76b4044ccb17b218e5a29f104b5325a068ab32e652e21a1ec95"></a>SPI_TRANSFER_MODE_2&#160;</td><td class="fielddoc"><p>Mode 2. Leading edge: falling, sample. Trailing edge: rising, setup </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9c30fdfffba6be76b4044ccb17b218e5a98dfa4850997601437f5183699d9e63c"></a>SPI_TRANSFER_MODE_3&#160;</td><td class="fielddoc"><p>Mode 3. Leading edge: falling, setup. Trailing edge: rising, sample </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga71091c8fcde0d526329e04f8c7b24efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71091c8fcde0d526329e04f8c7b24efc">&#9670;&nbsp;</a></span>_spi_interrupt_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _spi_interrupt_handler </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prototype for the interrupt handler </p>

</div>
</div>
<a id="ga74d13a9fe3203f121664b864f68c94fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74d13a9fe3203f121664b864f68c94fd">&#9670;&nbsp;</a></span>spi_abort_job()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_abort_job </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts an ongoing job. </p>
<p>This function will abort the specified job type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to SPI software instance struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga83b840fe8c91173bfe54a13787c262e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83b840fe8c91173bfe54a13787c262e6">&#9670;&nbsp;</a></span>spi_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> spi_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_sercom.html">Sercom</a> *const&#160;</td>
          <td class="paramname"><em>hw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structspi__config.html">spi_config</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the SERCOM SPI module. </p>
<p>This function will initialize the SERCOM SPI module, based on the values of the config struct.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hw</td><td>Pointer to hardware instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to the config struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the initialization. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>Module initiated correctly </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If module is enabled </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If module is busy resetting </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If invalid argument(s) were provided </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac5022683cb35d827578c26cf7689ae61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5022683cb35d827578c26cf7689ae61">&#9670;&nbsp;</a></span>spi_read_buffer_job()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> spi_read_buffer_job </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dummy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous buffer read. </p>
<p>Sets up the driver to read from the SPI to a given buffer. If registered and enabled, a callback function will be called when the read is finished.</p>
<dl class="section note"><dt>Note</dt><dd>If address matching is enabled for the slave, the first character received and placed in the RX buffer will be the address.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to SPI software instance struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_data</td><td>Pointer to data buffer to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Data buffer length </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dummy</td><td>Dummy character to send when reading in master mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the operation completed successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_BUSY</td><td>If the SPI was already busy with a read operation </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If the receiver is not enabled </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If requested read length was zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7cdeea24cfa24ab872044c6fa1ae893f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7cdeea24cfa24ab872044c6fa1ae893f">&#9670;&nbsp;</a></span>spi_read_buffer_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> spi_read_buffer_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>dummy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads buffer of <code>length</code> SPI characters. </p>
<p>This function will read a buffer of data from an SPI peripheral by sending dummy SPI character if in master mode, or by waiting for data in slave mode.</p>
<dl class="section note"><dt>Note</dt><dd>If address matching is enabled for the slave, the first character received and placed in the buffer will be the address.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_data</td><td>Data buffer for received data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Length of data to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dummy</td><td>8- or 9-bit dummy byte to shift out in master mode</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the read operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the read was completed </td></tr>
    <tr><td class="paramname">STATUS_ABORTED</td><td>If transaction was ended by master before the entire buffer was transferred </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If invalid argument(s) were provided </td></tr>
    <tr><td class="paramname">STATUS_ERR_TIMEOUT</td><td>If the operation was not completed within the timeout in slave mode </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If the receiver is not enabled </td></tr>
    <tr><td class="paramname">STATUS_ERR_OVERFLOW</td><td>If the data is overflown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9736ace2b57a6d45d3fb820aae552a48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9736ace2b57a6d45d3fb820aae552a48">&#9670;&nbsp;</a></span>spi_register_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_register_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga88d771c03a254735de0053be3fa513ca">spi_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga4afb8830e0197ec11f6beb8140210a88">spi_callback</a>&#160;</td>
          <td class="paramname"><em>callback_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers a SPI callback function. </p>
<p>Registers a callback function which is implemented by the user.</p>
<dl class="section note"><dt>Note</dt><dd>The callback must be enabled by spi_enable_callback, in order for the interrupt handler to call it when the conditions for the callback type are met.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to USART software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_func</td><td>Pointer to callback function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_type</td><td>Callback type given by an enum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65c764f92ed46f0d4845232bd4b241bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65c764f92ed46f0d4845232bd4b241bc">&#9670;&nbsp;</a></span>spi_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the SPI module. </p>
<p>This function will reset the SPI module to its power on default values and disable it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaff6f75d83ec5251e6d1d42830b8af05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff6f75d83ec5251e6d1d42830b8af05f">&#9670;&nbsp;</a></span>spi_select_slave()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> spi_select_slave </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structspi__slave__inst.html">spi_slave_inst</a> *const&#160;</td>
          <td class="paramname"><em>slave</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__sam0__utils.html#ga97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td>
          <td class="paramname"><em>select</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects slave device. </p>
<p>This function will drive the slave select pin of the selected device low or high depending on the select Boolean. If slave address recognition is enabled, the address will be sent to the slave when selecting it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to the software module struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">slave</td><td>Pointer to the attached slave </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">select</td><td>Boolean stating if the slave should be selected or deselected</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the slave device was selected </td></tr>
    <tr><td class="paramname">STATUS_ERR_UNSUPPORTED_DEV</td><td>If the SPI module is operating in slave mode </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If the SPI module is not ready to write the slave address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6bc86fe61f20b414ac3ca1a74c28dd28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bc86fe61f20b414ac3ca1a74c28dd28">&#9670;&nbsp;</a></span>spi_set_baudrate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> spi_set_baudrate </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>baudrate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the baudrate of the SPI module. </p>
<p>This function will set the baudrate of the SPI module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">baudrate</td><td>The baudrate wanted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The status of the configuration. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If invalid argument(s) were provided </td></tr>
    <tr><td class="paramname">STATUS_OK</td><td>If the configuration was written </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaba6ac49efcf4b51fa8131d4a07071967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaba6ac49efcf4b51fa8131d4a07071967">&#9670;&nbsp;</a></span>spi_transceive_buffer_job()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> spi_transceive_buffer_job </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous buffer write and read. </p>
<p>Sets up the driver to write and read to and from given buffers. If registered and enabled, a callback function will be called when the transfer is finished.</p>
<dl class="section note"><dt>Note</dt><dd>If address matching is enabled for the slave, the first character received and placed in the RX buffer will be the address.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to SPI software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx_data</td><td>Pointer to data buffer to send </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_data</td><td>Pointer to data buffer to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Data buffer length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the operation completed successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_BUSY</td><td>If the SPI was already busy with a read operation </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If the receiver is not enabled </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If requested read length was zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad784fee69a16acef8e4e3b8be4a4d61d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad784fee69a16acef8e4e3b8be4a4d61d">&#9670;&nbsp;</a></span>spi_transceive_buffer_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> spi_transceive_buffer_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>rx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends and receives a buffer of <code>length</code> SPI characters. </p>
<p>This function will send and receive a buffer of data via the SPI.</p>
<p>In master mode the SPI characters will be sent immediately and the received SPI character will be read as soon as the shifting of the SPI character is complete.</p>
<p>In slave mode this function will place the data to be sent into the transmit buffer. It will then block until an SPI master has shifted the complete buffer and the received data is available.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx_data</td><td>Pointer to the buffer to transmit </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_data</td><td>Pointer to the buffer where received data will be stored </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of SPI characters to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the operation was completed </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If invalid argument(s) were provided </td></tr>
    <tr><td class="paramname">STATUS_ERR_TIMEOUT</td><td>If the operation was not completed within the timeout in slave mode </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If the receiver is not enabled </td></tr>
    <tr><td class="paramname">STATUS_ERR_OVERFLOW</td><td>If the data is overflown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3eb1d72360e67b6fef7574320a5919e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3eb1d72360e67b6fef7574320a5919e6">&#9670;&nbsp;</a></span>spi_transceive_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> spi_transceive_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>rx_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends and reads a single SPI character. </p>
<p>This function will transfer a single SPI character via SPI and return the SPI character that is shifted into the shift register.</p>
<p>In master mode the SPI character will be sent immediately and the received SPI character will be read as soon as the shifting of the data is complete.</p>
<p>In slave mode this function will place the data to be sent into the transmit buffer. It will then block until an SPI master has shifted a complete SPI character, and the received data is available.</p>
<dl class="section note"><dt>Note</dt><dd>The data to be sent might not be sent before the next transfer, as loading of the shift register is dependent on SCK. </dd>
<dd>
If address matching is enabled for the slave, the first character received and placed in the buffer will be the address.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx_data</td><td>SPI character to transmit </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rx_data</td><td>Pointer to store the received SPI character</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the operation was completed </td></tr>
    <tr><td class="paramname">STATUS_ERR_TIMEOUT</td><td>If the operation was not completed within the timeout in slave mode </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If the receiver is not enabled </td></tr>
    <tr><td class="paramname">STATUS_ERR_OVERFLOW</td><td>If the incoming data is overflown </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7df7ed6a6a9d6a5e1338ceaa0d5f07b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7df7ed6a6a9d6a5e1338ceaa0d5f07b2">&#9670;&nbsp;</a></span>spi_unregister_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void spi_unregister_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#ga4afb8830e0197ec11f6beb8140210a88">spi_callback</a>&#160;</td>
          <td class="paramname"><em>callback_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters a SPI callback function. </p>
<p>Unregisters a callback function which is implemented by the user.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to SPI software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_type</td><td>Callback type given by an enum </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7a7ddeab7e3ed355e13366ed635ff152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a7ddeab7e3ed355e13366ed635ff152">&#9670;&nbsp;</a></span>spi_write_buffer_job()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> spi_write_buffer_job </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronous buffer write. </p>
<p>Sets up the driver to write to the SPI from a given buffer. If registered and enabled, a callback function will be called when the write is finished.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to SPI software instance struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">tx_data</td><td>Pointer to data buffer to receive </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Data buffer length</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write request operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the operation completed successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_BUSY</td><td>If the SPI was already busy with a write operation </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If requested write length was zero </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae217dcf01506d2ad9ea554a14e57245f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae217dcf01506d2ad9ea554a14e57245f">&#9670;&nbsp;</a></span>spi_write_buffer_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> spi_write_buffer_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structspi__module.html">spi_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>tx_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends a buffer of <code>length</code> SPI characters. </p>
<p>This function will send a buffer of SPI characters via the SPI and discard any data that is received. To both send and receive a buffer of data, use the <a class="el" href="group__asfdoc__sam0__sercom__spi__group.html#gad784fee69a16acef8e4e3b8be4a4d61d">spi_transceive_buffer_wait</a> function.</p>
<p>Note that this function does not handle the _SS (slave select) pin(s) in master mode; this must be handled by the user application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tx_data</td><td>Pointer to the buffer to transmit </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>Number of SPI characters to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the write operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If the write was completed </td></tr>
    <tr><td class="paramname">STATUS_ABORTED</td><td>If transaction was ended by master before entire buffer was transferred </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>If invalid argument(s) were provided </td></tr>
    <tr><td class="paramname">STATUS_ERR_TIMEOUT</td><td>If the operation was not completed within the timeout in slave mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
