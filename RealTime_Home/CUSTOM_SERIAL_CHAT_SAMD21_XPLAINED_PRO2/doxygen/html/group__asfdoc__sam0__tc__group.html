<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RealTime_Home: SAM Timer/Counter (TC) Driver</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RealTime_Home
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__asfdoc__sam0__tc__group.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">SAM Timer/Counter (TC) Driver</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__events.html">tc_events</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TC event enable/disable structure.  <a href="structtc__events.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__8bit__config.html">tc_8bit_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for TC module in 8-bit size counter mode.  <a href="structtc__8bit__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__16bit__config.html">tc_16bit_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for TC module in 16-bit size counter mode.  <a href="structtc__16bit__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__32bit__config.html">tc_32bit_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for TC module in 32-bit size counter mode.  <a href="structtc__32bit__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__pwm__channel.html">tc_pwm_channel</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration struct for TC module in 32-bit size counter mode.  <a href="structtc__pwm__channel.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__config.html">tc_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TC configuration structure.  <a href="structtc__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtc__module.html">tc_module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TC software device instance structure.  <a href="structtc__module.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac837f9db5df1793578c195a979c6a9d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gac837f9db5df1793578c195a979c6a9d3">NUMBER_OF_COMPARE_CAPTURE_CHANNELS</a>&#160;&#160;&#160;<a class="el" href="tc3_8h.html#a2d4adcedec07af5cc0519e42d1bf2180">TC3_CC8_NUM</a></td></tr>
<tr class="separator:gac837f9db5df1793578c195a979c6a9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94cdbe531468f0975311bc2ce36f5e1c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga94cdbe531468f0975311bc2ce36f5e1c">TC_INST_MAX_ID</a>&#160;&#160;&#160;7</td></tr>
<tr class="separator:ga94cdbe531468f0975311bc2ce36f5e1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga7d3fb5365e46bd4efae2885bd508067f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga7d3fb5365e46bd4efae2885bd508067f">tc_callback</a> { <br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tc__group.html#gga7d3fb5365e46bd4efae2885bd508067fade9a99ec0d7386cfff45671de03b8b6a">TC_CALLBACK_OVERFLOW</a>, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga7d3fb5365e46bd4efae2885bd508067fab6fb975aff8c4ace0dbece4bf825332b">TC_CALLBACK_ERROR</a>, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga7d3fb5365e46bd4efae2885bd508067fa03e7143b9984e00ad432db650abd69c6">TC_CALLBACK_CC_CHANNEL0</a>, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga7d3fb5365e46bd4efae2885bd508067fae16450d1f8ef97cc1b129524b72efdf3">TC_CALLBACK_CC_CHANNEL1</a>, 
<br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tc__group.html#gga7d3fb5365e46bd4efae2885bd508067faf76c479c366d3c15450245bb4ee9a856">TC_CALLBACK_N</a>
<br />
 }</td></tr>
<tr class="separator:ga7d3fb5365e46bd4efae2885bd508067f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01eca97dbfd588fd3ba0dcfd4792d857"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga01eca97dbfd588fd3ba0dcfd4792d857">tc_compare_capture_channel</a> { <a class="el" href="group__asfdoc__sam0__tc__group.html#gga01eca97dbfd588fd3ba0dcfd4792d857a5f6651d829a75778a759ce5a519b76a4">TC_COMPARE_CAPTURE_CHANNEL_0</a>, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga01eca97dbfd588fd3ba0dcfd4792d857a8fcf38e3b831977347028475b5583141">TC_COMPARE_CAPTURE_CHANNEL_1</a>
 }</td></tr>
<tr class="memdesc:ga01eca97dbfd588fd3ba0dcfd4792d857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index of the compare capture channels.  <a href="group__asfdoc__sam0__tc__group.html#ga01eca97dbfd588fd3ba0dcfd4792d857">More...</a><br /></td></tr>
<tr class="separator:ga01eca97dbfd588fd3ba0dcfd4792d857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7f1302b7e3d675e471a554668b49d64"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gae7f1302b7e3d675e471a554668b49d64">tc_wave_generation</a> { <a class="el" href="group__asfdoc__sam0__tc__group.html#ggae7f1302b7e3d675e471a554668b49d64a544e51b015f20263a9499ce28a0596e7">TC_WAVE_GENERATION_NORMAL_FREQ</a> = TC_WAVE_GENERATION_NORMAL_FREQ_MODE, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#ggae7f1302b7e3d675e471a554668b49d64a4c9b3fe1ad9a1d2c0f5d8544c0923b9f">TC_WAVE_GENERATION_MATCH_FREQ</a> = TC_WAVE_GENERATION_MATCH_FREQ_MODE, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#ggae7f1302b7e3d675e471a554668b49d64aad9dc196250ce8ca5a98c7e49cf0c1a9">TC_WAVE_GENERATION_NORMAL_PWM</a> = TC_WAVE_GENERATION_NORMAL_PWM_MODE, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#ggae7f1302b7e3d675e471a554668b49d64a973273609713f828ce491f56fbf035d2">TC_WAVE_GENERATION_MATCH_PWM</a> = TC_WAVE_GENERATION_MATCH_PWM_MODE
 }</td></tr>
<tr class="memdesc:gae7f1302b7e3d675e471a554668b49d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">TC wave generation mode enum.  <a href="group__asfdoc__sam0__tc__group.html#gae7f1302b7e3d675e471a554668b49d64">More...</a><br /></td></tr>
<tr class="separator:gae7f1302b7e3d675e471a554668b49d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b112627b81227c49c16b1a93e3321a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga1b112627b81227c49c16b1a93e3321a0">tc_counter_size</a> { <a class="el" href="group__asfdoc__sam0__tc__group.html#gga1b112627b81227c49c16b1a93e3321a0abf2e8000eeeac2a4f259ba117d1ee934">TC_COUNTER_SIZE_8BIT</a> = TC_CTRLA_MODE_COUNT8, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga1b112627b81227c49c16b1a93e3321a0a07c9fe9d2a5e78a9c1be46ce540adad1">TC_COUNTER_SIZE_16BIT</a> = TC_CTRLA_MODE_COUNT16, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga1b112627b81227c49c16b1a93e3321a0a7d28e63b11a550605d003c894fe134c5">TC_COUNTER_SIZE_32BIT</a> = TC_CTRLA_MODE_COUNT32
 }</td></tr>
<tr class="memdesc:ga1b112627b81227c49c16b1a93e3321a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies if the counter is 8-, 16-, or 32-bit.  <a href="group__asfdoc__sam0__tc__group.html#ga1b112627b81227c49c16b1a93e3321a0">More...</a><br /></td></tr>
<tr class="separator:ga1b112627b81227c49c16b1a93e3321a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga204bb4814c91e62e56d9297c05280aad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga204bb4814c91e62e56d9297c05280aad">tc_reload_action</a> { <a class="el" href="group__asfdoc__sam0__tc__group.html#gga204bb4814c91e62e56d9297c05280aadaea50b7d7b79cfbd72298720e0f6d51ed">TC_RELOAD_ACTION_GCLK</a> = TC_CTRLA_PRESCSYNC_GCLK, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga204bb4814c91e62e56d9297c05280aada97857fba0947beb9110ab79d2990e559">TC_RELOAD_ACTION_PRESC</a> = TC_CTRLA_PRESCSYNC_PRESC, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga204bb4814c91e62e56d9297c05280aadac78b7c50f80b33d5ef15a63348279f17">TC_RELOAD_ACTION_RESYNC</a> = TC_CTRLA_PRESCSYNC_RESYNC
 }</td></tr>
<tr class="memdesc:ga204bb4814c91e62e56d9297c05280aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">TC Counter reload action enum.  <a href="group__asfdoc__sam0__tc__group.html#ga204bb4814c91e62e56d9297c05280aad">More...</a><br /></td></tr>
<tr class="separator:ga204bb4814c91e62e56d9297c05280aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98aed17b995157e67b9322a45f0ed5f4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga98aed17b995157e67b9322a45f0ed5f4">tc_clock_prescaler</a> { <br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4abee76ee986e815120c67ff104dd77275">TC_CLOCK_PRESCALER_DIV1</a> = TC_CTRLA_PRESCALER(0), 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4a6326eb4305153ea58ea18ee6a74bc8f0">TC_CLOCK_PRESCALER_DIV2</a> = TC_CTRLA_PRESCALER(1), 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4a8c137a94b34809e544d50680c808da23">TC_CLOCK_PRESCALER_DIV4</a> = TC_CTRLA_PRESCALER(2), 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4a3dbb4f263ba1e940954ffe8a667bf7d1">TC_CLOCK_PRESCALER_DIV8</a> = TC_CTRLA_PRESCALER(3), 
<br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4aa0bec32bcf9a450d950f9ec9941a6c3a">TC_CLOCK_PRESCALER_DIV16</a> = TC_CTRLA_PRESCALER(4), 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4aea8fd1d9e795ec153e80cddc15ad501b">TC_CLOCK_PRESCALER_DIV64</a> = TC_CTRLA_PRESCALER(5), 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4a72552d0e6095d90da22981b7bd7a33ed">TC_CLOCK_PRESCALER_DIV256</a> = TC_CTRLA_PRESCALER(6), 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga98aed17b995157e67b9322a45f0ed5f4af1540c54586b7cd0c5e46c60162951ec">TC_CLOCK_PRESCALER_DIV1024</a> = TC_CTRLA_PRESCALER(7)
<br />
 }</td></tr>
<tr class="memdesc:ga98aed17b995157e67b9322a45f0ed5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">TC clock prescaler values.  <a href="group__asfdoc__sam0__tc__group.html#ga98aed17b995157e67b9322a45f0ed5f4">More...</a><br /></td></tr>
<tr class="separator:ga98aed17b995157e67b9322a45f0ed5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28777c47943dfb2b5de0fd7ae14eac1f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga28777c47943dfb2b5de0fd7ae14eac1f">tc_count_direction</a> { <a class="el" href="group__asfdoc__sam0__tc__group.html#gga28777c47943dfb2b5de0fd7ae14eac1faf247abdaef160b832fd09bc7597e8ca3">TC_COUNT_DIRECTION_UP</a>, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga28777c47943dfb2b5de0fd7ae14eac1fade3defd512c1bff05ce6302c2d96b014">TC_COUNT_DIRECTION_DOWN</a>
 }</td></tr>
<tr class="memdesc:ga28777c47943dfb2b5de0fd7ae14eac1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">TC module count direction.  <a href="group__asfdoc__sam0__tc__group.html#ga28777c47943dfb2b5de0fd7ae14eac1f">More...</a><br /></td></tr>
<tr class="separator:ga28777c47943dfb2b5de0fd7ae14eac1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Module Status Flags</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrpdd98d5e8b9a5fd30d323c8eeeab117f4"></a>TC status flags, returned by tc_get_status() and cleared by tc_clear_status(). </p>
</td></tr>
<tr class="memitem:gae74e90dac05478452203a41a88853286"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gae74e90dac05478452203a41a88853286">TC_STATUS_CHANNEL_0_MATCH</a>&#160;&#160;&#160;(1UL &lt;&lt; 0)</td></tr>
<tr class="separator:gae74e90dac05478452203a41a88853286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab140d8ac7858f45029fddf0fd3f4cf3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gaab140d8ac7858f45029fddf0fd3f4cf3">TC_STATUS_CHANNEL_1_MATCH</a>&#160;&#160;&#160;(1UL &lt;&lt; 1)</td></tr>
<tr class="separator:gaab140d8ac7858f45029fddf0fd3f4cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73bfbe04c8834ec55242bcd0b678f94e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga73bfbe04c8834ec55242bcd0b678f94e">TC_STATUS_SYNC_READY</a>&#160;&#160;&#160;(1UL &lt;&lt; 2)</td></tr>
<tr class="separator:ga73bfbe04c8834ec55242bcd0b678f94e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac13395d51cc03b5c43eda7654649925f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gac13395d51cc03b5c43eda7654649925f">TC_STATUS_CAPTURE_OVERFLOW</a>&#160;&#160;&#160;(1UL &lt;&lt; 3)</td></tr>
<tr class="separator:gac13395d51cc03b5c43eda7654649925f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada6e9a6bd144c0c2e360d1fdef944cdd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gada6e9a6bd144c0c2e360d1fdef944cdd">TC_STATUS_COUNT_OVERFLOW</a>&#160;&#160;&#160;(1UL &lt;&lt; 4)</td></tr>
<tr class="separator:gada6e9a6bd144c0c2e360d1fdef944cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
TC Wave Generation Mode</h2></td></tr>
<tr class="memitem:ga3be501afca9dd97d2adb1959f30816a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga3be501afca9dd97d2adb1959f30816a7">TC_WAVE_GENERATION_NORMAL_FREQ_MODE</a>&#160;&#160;&#160;<a class="el" href="group___s_a_m_d21___t_c.html#ga3d7b144f5e197d57332ab754b75b12c9">TC_CTRLA_WAVEGEN_NFRQ</a></td></tr>
<tr class="separator:ga3be501afca9dd97d2adb1959f30816a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65ebbd3eaea3bd9cf6f81392770caae6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga65ebbd3eaea3bd9cf6f81392770caae6">TC_WAVE_GENERATION_MATCH_FREQ_MODE</a>&#160;&#160;&#160;<a class="el" href="group___s_a_m_d21___t_c.html#ga481c00b2ec0ab62d5c321b1f3fb32493">TC_CTRLA_WAVEGEN_MFRQ</a></td></tr>
<tr class="separator:ga65ebbd3eaea3bd9cf6f81392770caae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7277c5eaa031dbd06159cd533346210"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gaa7277c5eaa031dbd06159cd533346210">TC_WAVE_GENERATION_NORMAL_PWM_MODE</a>&#160;&#160;&#160;<a class="el" href="group___s_a_m_d21___t_c.html#ga74de3c0bcf4adf87189c90b28cd7310d">TC_CTRLA_WAVEGEN_NPWM</a></td></tr>
<tr class="separator:gaa7277c5eaa031dbd06159cd533346210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4636ecc5d5a67c47a8b6551568c31ee6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga4636ecc5d5a67c47a8b6551568c31ee6">TC_WAVE_GENERATION_MATCH_PWM_MODE</a>&#160;&#160;&#160;<a class="el" href="group___s_a_m_d21___t_c.html#gac9b02e2cfc519e0fc97c3b89efdc7be1">TC_CTRLA_WAVEGEN_MPWM</a></td></tr>
<tr class="separator:ga4636ecc5d5a67c47a8b6551568c31ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Waveform Inversion Mode</h2></td></tr>
<tr class="memitem:gaf681729d6b5f963705871f7d80754166"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gaf681729d6b5f963705871f7d80754166">tc_waveform_invert_output</a> { <a class="el" href="group__asfdoc__sam0__tc__group.html#ggaf681729d6b5f963705871f7d80754166a292cfce35b768eecd69f2a4320aaa96b">TC_WAVEFORM_INVERT_OUTPUT_NONE</a> = 0, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#ggaf681729d6b5f963705871f7d80754166af3ebe1706d0f442c6388619bc3d9fa58">TC_WAVEFORM_INVERT_OUTPUT_CHANNEL_0</a> = TC_WAVEFORM_INVERT_CC0_MODE, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#ggaf681729d6b5f963705871f7d80754166a97327e36339fbad207e7150d6ba7b283">TC_WAVEFORM_INVERT_OUTPUT_CHANNEL_1</a> = TC_WAVEFORM_INVERT_CC1_MODE
 }</td></tr>
<tr class="memdesc:gaf681729d6b5f963705871f7d80754166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waveform inversion mode.  <a href="group__asfdoc__sam0__tc__group.html#gaf681729d6b5f963705871f7d80754166">More...</a><br /></td></tr>
<tr class="separator:gaf681729d6b5f963705871f7d80754166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4dcbf6cdb74bc3b7609ce8d16549462f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga4dcbf6cdb74bc3b7609ce8d16549462f">tc_event_action</a> { <br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tc__group.html#gga4dcbf6cdb74bc3b7609ce8d16549462fa190e10df25f3f6a6c781cc751eb3489e">TC_EVENT_ACTION_OFF</a> = TC_EVCTRL_EVACT_OFF, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga4dcbf6cdb74bc3b7609ce8d16549462fa9696961ae81b1aba22582d8a35bdf14d">TC_EVENT_ACTION_RETRIGGER</a> = TC_EVCTRL_EVACT_RETRIGGER, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga4dcbf6cdb74bc3b7609ce8d16549462fa07b969496782cb311ddb13cfafb36aff">TC_EVENT_ACTION_INCREMENT_COUNTER</a> = TC_EVCTRL_EVACT_COUNT, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga4dcbf6cdb74bc3b7609ce8d16549462fac06c64382b572d0464138ae51b7876df">TC_EVENT_ACTION_START</a> = TC_EVCTRL_EVACT_START, 
<br />
&#160;&#160;<a class="el" href="group__asfdoc__sam0__tc__group.html#gga4dcbf6cdb74bc3b7609ce8d16549462fa4957024d607401030b128f9b775edb7d">TC_EVENT_ACTION_PPW</a> = TC_EVCTRL_EVACT_PPW, 
<a class="el" href="group__asfdoc__sam0__tc__group.html#gga4dcbf6cdb74bc3b7609ce8d16549462face22a0756d93b16a9b70511fe226a893">TC_EVENT_ACTION_PWP</a> = TC_EVCTRL_EVACT_PWP
<br />
 }</td></tr>
<tr class="memdesc:ga4dcbf6cdb74bc3b7609ce8d16549462f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Action to perform when the TC module is triggered by an event.  <a href="group__asfdoc__sam0__tc__group.html#ga4dcbf6cdb74bc3b7609ce8d16549462f">More...</a><br /></td></tr>
<tr class="separator:ga4dcbf6cdb74bc3b7609ce8d16549462f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2a1d57f42085001f29a6584ae8ab1bb4"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga2a1d57f42085001f29a6584ae8ab1bb4">tc_callback_t</a>) (struct <a class="el" href="structtc__module.html">tc_module</a> *const module)</td></tr>
<tr class="separator:ga2a1d57f42085001f29a6584ae8ab1bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga077a238b03327682013a0bceb4fc44b2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga077a238b03327682013a0bceb4fc44b2">_tc_get_inst_index</a> (<a class="el" href="union_tc.html">Tc</a> *const hw)</td></tr>
<tr class="separator:ga077a238b03327682013a0bceb4fc44b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga50cb4d965dd6d607839abb71b3f034c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga50cb4d965dd6d607839abb71b3f034c0">TC_WAVEFORM_INVERT_CC0_MODE</a>&#160;&#160;&#160;<a class="el" href="group___s_a_m_d21___t_c.html#gabcaa416dc792b45f9ea315455d3ab4c0">TC_CTRLC_INVEN</a>(1)</td></tr>
<tr class="separator:ga50cb4d965dd6d607839abb71b3f034c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae194715d12d4faa15f1d1b8555bf5b53"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gae194715d12d4faa15f1d1b8555bf5b53">TC_WAVEFORM_INVERT_CC1_MODE</a>&#160;&#160;&#160;<a class="el" href="group___s_a_m_d21___t_c.html#gabcaa416dc792b45f9ea315455d3ab4c0">TC_CTRLC_INVEN</a>(2)</td></tr>
<tr class="separator:gae194715d12d4faa15f1d1b8555bf5b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Driver Initialization and Configuration</h2></td></tr>
<tr class="memitem:ga98c7f5c97436c2f6cff87a0261597337"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga98c7f5c97436c2f6cff87a0261597337">tc_init</a> (struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst, <a class="el" href="union_tc.html">Tc</a> *const hw, const struct <a class="el" href="structtc__config.html">tc_config</a> *const config)</td></tr>
<tr class="memdesc:ga98c7f5c97436c2f6cff87a0261597337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a hardware TC module instance.  <a href="#ga98c7f5c97436c2f6cff87a0261597337">More...</a><br /></td></tr>
<tr class="separator:ga98c7f5c97436c2f6cff87a0261597337"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Enable/Disable/Reset</h2></td></tr>
<tr class="memitem:gad147c1f0393a3ae0c830cec73986eddd"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gad147c1f0393a3ae0c830cec73986eddd">tc_reset</a> (const struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst)</td></tr>
<tr class="memdesc:gad147c1f0393a3ae0c830cec73986eddd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the TC module.  <a href="#gad147c1f0393a3ae0c830cec73986eddd">More...</a><br /></td></tr>
<tr class="separator:gad147c1f0393a3ae0c830cec73986eddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Get/Set Count Value</h2></td></tr>
<tr class="memitem:gae7d7eb91616c2dff02886dd8cdc87f2d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gae7d7eb91616c2dff02886dd8cdc87f2d">tc_get_count_value</a> (const struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst)</td></tr>
<tr class="memdesc:gae7d7eb91616c2dff02886dd8cdc87f2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get TC module count value.  <a href="#gae7d7eb91616c2dff02886dd8cdc87f2d">More...</a><br /></td></tr>
<tr class="separator:gae7d7eb91616c2dff02886dd8cdc87f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c81066b0b88893e127fa521f0efde2e"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga9c81066b0b88893e127fa521f0efde2e">tc_set_count_value</a> (const struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst, const uint32_t count)</td></tr>
<tr class="memdesc:ga9c81066b0b88893e127fa521f0efde2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets TC module count value.  <a href="#ga9c81066b0b88893e127fa521f0efde2e">More...</a><br /></td></tr>
<tr class="separator:ga9c81066b0b88893e127fa521f0efde2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Get Capture Set Compare</h2></td></tr>
<tr class="memitem:gaf780bb09a00298868aa3b8e7627f92ff"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gaf780bb09a00298868aa3b8e7627f92ff">tc_get_capture_value</a> (const struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst, const enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga01eca97dbfd588fd3ba0dcfd4792d857">tc_compare_capture_channel</a> channel_index)</td></tr>
<tr class="memdesc:gaf780bb09a00298868aa3b8e7627f92ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the TC module capture value.  <a href="#gaf780bb09a00298868aa3b8e7627f92ff">More...</a><br /></td></tr>
<tr class="separator:gaf780bb09a00298868aa3b8e7627f92ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga687208b24fd33a1da0cbe683adc15fa6"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#ga687208b24fd33a1da0cbe683adc15fa6">tc_set_compare_value</a> (const struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst, const enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga01eca97dbfd588fd3ba0dcfd4792d857">tc_compare_capture_channel</a> channel_index, const uint32_t compare_value)</td></tr>
<tr class="memdesc:ga687208b24fd33a1da0cbe683adc15fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a TC module compare value.  <a href="#ga687208b24fd33a1da0cbe683adc15fa6">More...</a><br /></td></tr>
<tr class="separator:ga687208b24fd33a1da0cbe683adc15fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Set Top Value</h2></td></tr>
<tr class="memitem:gac22d633ece43bcd18f54283778471340"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__tc__group.html#gac22d633ece43bcd18f54283778471340">tc_set_top_value</a> (const struct <a class="el" href="structtc__module.html">tc_module</a> *const module_inst, const uint32_t top_value)</td></tr>
<tr class="memdesc:gac22d633ece43bcd18f54283778471340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the timer TOP/period value.  <a href="#gac22d633ece43bcd18f54283778471340">More...</a><br /></td></tr>
<tr class="separator:gac22d633ece43bcd18f54283778471340"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>This driver for Atmel&reg; | SMART ARM&reg;-based microcontrollers provides an interface for the configuration and management of the timer modules within the device, for waveform generation and timing operations. The following driver API modes are covered by this manual:</p>
<ul>
<li>Polled APIs</li>
</ul>
<p>The following peripheral is used by this module:</p><ul>
<li>TC (Timer/Counter)</li>
</ul>
<p>The following devices can use this module:</p><ul>
<li>Atmel | SMART SAM D20/D21</li>
<li>Atmel | SMART SAM R21</li>
<li>Atmel | SMART SAM D09/D10/D11</li>
<li>Atmel | SMART SAM L21/L22</li>
<li>Atmel | SMART SAM DA1</li>
<li>Atmel | SMART SAM C20/C21</li>
<li>Atmel | SMART SAM HA1</li>
</ul>
<p>The outline of this documentation is as follows:</p><ul>
<li><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_prerequisites">Prerequisites</a></li>
<li><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_module_overview">Module Overview</a></li>
<li><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_special_considerations">Special Considerations</a></li>
<li><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_extra_info">Extra Information</a></li>
<li><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_examples">Examples</a></li>
<li><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_api_overview">API Overview</a></li>
</ul>
<h1><a class="anchor" id="asfdoc_sam0_tc_prerequisites"></a>
Prerequisites</h1>
<p>There are no prerequisites for this module.</p>
<h1><a class="anchor" id="asfdoc_sam0_tc_module_overview"></a>
Module Overview</h1>
<p>The Timer/Counter (TC) module provides a set of timing and counting related functionality, such as the generation of periodic waveforms, the capturing of a periodic waveform's frequency/duty cycle, and software timekeeping for periodic operations. TC modules can be configured to use an 8-, 16-, or 32-bit counter size.</p>
<p>This TC module for the SAM is capable of the following functions:</p>
<ul>
<li>Generation of PWM signals</li>
<li>Generation of timestamps for events</li>
<li>General time counting</li>
<li>Waveform period capture</li>
<li>Waveform frequency capture</li>
</ul>
<p><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_block_diagram">The diagram below</a> shows the overview of the TC module design.</p>
<p><a class="anchor" id="asfdoc_sam0_tc_block_diagram"></a> </p><div class="image">
<object type="image/svg+xml" data="overview.svg">overview.svg</object>
<div class="caption">
Basic Overview of the TC Module</div></div>
<h2><a class="anchor" id="asfdoc_sam0_tc_features"></a>
Driver Feature Macro Definition</h2>
<table class="doxtable">
<tr>
<th>Driver Feature Macro </th><th>Supported devices  </th></tr>
<tr>
<td>FEATURE_TC_DOUBLE_BUFFERED </td><td>SAM L21/L22/C20/C21  </td></tr>
<tr>
<td>FEATURE_TC_SYNCBUSY_SCHEME_VERSION_2 </td><td>SAM L21/L22/C20/C21  </td></tr>
<tr>
<td>FEATURE_TC_STAMP_PW_CAPTURE </td><td>SAM L21/L22/C20/C21  </td></tr>
<tr>
<td>FEATURE_TC_READ_SYNC </td><td>SAM L21/L22/C20/C21  </td></tr>
<tr>
<td>FEATURE_TC_IO_CAPTURE </td><td>SAM L21/L22/C20/C21  </td></tr>
<tr>
<td>FEATURE_TC_GENERATE_DMA_TRIGGER </td><td>SAM L21/L22  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The specific features are only available in the driver when the selected device supports those features.</dd></dl>
<h2><a class="anchor" id="asfdoc_sam0_tc_module_overview_func_desc"></a>
Functional Description</h2>
<p>Independent of the configured counter size, each TC module can be set up in one of two different modes; capture and compare.</p>
<p>In capture mode, the counter value is stored when a configurable event occurs. This mode can be used to generate timestamps used in event capture, or it can be used for the measurement of a periodic input signal's frequency/duty cycle.</p>
<p>In compare mode, the counter value is compared against one or more of the configured channel compare values. When the counter value coincides with a compare value an action can be taken automatically by the module, such as generating an output event or toggling a pin when used for frequency or Pulse Width Modulation (PWM) signal generation.</p>
<dl class="section note"><dt>Note</dt><dd>The connection of events between modules requires the use of the SAM Event System Driver (EVENTS) to route output event of one module to the input event of another. For more information on event routing, refer to the event driver documentation.</dd></dl>
<h2><a class="anchor" id="asfdoc_sam0_tc_module_overview_tc_size"></a>
Timer/Counter Size</h2>
<p>Each timer module can be configured in one of three different counter sizes; 8-, 16-, and 32-bit. The size of the counter determines the maximum value it can count to before an overflow occurs and the count is reset back to zero. <a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_count_size_vs_top">The table below</a> shows the maximum values for each of the possible counter sizes.</p>
<p><a class="anchor" id="asfdoc_sam0_tc_count_size_vs_top"></a> </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>Timer Counter Sizes and Their Maximum Count Values</caption>
<tr>
<th>Counter size </th><th>Max. (hexadecimal) </th><th>Max. (decimal)  </th></tr>
<tr>
<td>8-bit </td><td>0xFF </td><td>255  </td></tr>
<tr>
<td>16-bit </td><td>0xFFFF </td><td>65,535  </td></tr>
<tr>
<td>32-bit </td><td>0xFFFFFFFF </td><td>4,294,967,295  </td></tr>
</table>
<p>When using the counter in 16- or 32-bit count mode, Compare Capture register 0 (CC0) is used to store the period value when running in PWM generation match mode.</p>
<p>When using 32-bit counter size, two 16-bit counters are chained together in a cascade formation. Except in SAM D09/D10/D11. Even numbered TC modules (e.g. TC0, TC2) can be configured as 32-bit counters. The odd numbered counters will act as slaves to the even numbered masters, and will not be reconfigurable until the master timer is disabled. The pairing of timer modules for 32-bit mode is shown in <a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_module_ms_pairs">the table below</a>.</p>
<p><a class="anchor" id="asfdoc_sam0_tc_module_ms_pairs"></a> </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>TC Master and Slave Module Pairings</caption>
<tr>
<th>Master TC module </th><th>Slave TC module  </th></tr>
<tr>
<td>TC0 </td><td>TC1  </td></tr>
<tr>
<td>TC2 </td><td>TC3  </td></tr>
<tr>
<td>... </td><td>...  </td></tr>
<tr>
<td>TCn-1 </td><td>TCn  </td></tr>
</table>
<p>In SAM D09/D10/D11, odd numbered TC modules (e.g. TC1) can be configured as 32-bit counters. The even numbered (e.g. TC2) counters will act as slaves to the odd numbered masters.</p>
<h2><a class="anchor" id="asfdoc_sam0_tc_module_overview_clock"></a>
Clock Settings</h2>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_clock_selection"></a>
Clock Selection</h3>
<p>Each TC peripheral is clocked asynchronously to the system clock by a GCLK (Generic Clock) channel. The GCLK channel connects to any of the GCLK generators. The GCLK generators are configured to use one of the available clock sources on the system such as internal oscillator, external crystals, etc. See the <a class="el" href="group__asfdoc__sam0__system__clock__group.html">Generic Clock driver</a> for more information.</p>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_clock_prescaler"></a>
Prescaler</h3>
<p>Each TC module in the SAM has its own individual clock prescaler, which can be used to divide the input clock frequency used in the counter. This prescaler only scales the clock used to provide clock pulses for the counter to count, and does not affect the digital register interface portion of the module, thus the timer registers will synchronize to the raw GCLK frequency input to the module.</p>
<p>As a result of this, when selecting a GCLK frequency and timer prescaler value the user application should consider both the timer resolution required and the synchronization frequency, to avoid lengthy synchronization times of the module if a very slow GCLK frequency is fed into the TC module. It is preferable to use a higher module GCLK frequency as the input to the timer, and prescale this down as much as possible to obtain a suitable counter frequency in latency-sensitive applications.</p>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_clock_reloading"></a>
Reloading</h3>
<p>Timer modules also contain a configurable reload action, used when a re-trigger event occurs. Examples of a re-trigger event are the counter reaching the maximum value when counting up, or when an event from the event system tells the counter to re-trigger. The reload action determines if the prescaler should be reset, and when this should happen. The counter will always be reloaded with the value it is set to start counting from. The user can choose between three different reload actions, described in <a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_module_reload_act">the table below</a>.</p>
<p><a class="anchor" id="asfdoc_sam0_tc_module_reload_act"></a> </p><a class="anchor" id=""></a>
<table class="doxtable">
<caption>TC Module Reload Actions</caption>
<tr>
<th>Reload action </th><th>Description  </th></tr>
<tr>
<td><a class="el" href="group__asfdoc__sam0__tc__group.html#gga204bb4814c91e62e56d9297c05280aadaea50b7d7b79cfbd72298720e0f6d51ed">TC_RELOAD_ACTION_GCLK</a>  </td><td>Reload TC counter value on next GCLK cycle. Leave prescaler as-is.  </td></tr>
<tr>
<td><a class="el" href="group__asfdoc__sam0__tc__group.html#gga204bb4814c91e62e56d9297c05280aada97857fba0947beb9110ab79d2990e559">TC_RELOAD_ACTION_PRESC</a>  </td><td>Reloads TC counter value on next prescaler clock. Leave prescaler as-is.  </td></tr>
<tr>
<td><a class="el" href="group__asfdoc__sam0__tc__group.html#gga204bb4814c91e62e56d9297c05280aadac78b7c50f80b33d5ef15a63348279f17">TC_RELOAD_ACTION_RESYNC</a>  </td><td>Reload TC counter value on next GCLK cycle. Clear prescaler to zero.  </td></tr>
</table>
<p>The reload action to use will depend on the specific application being implemented. One example is when an external trigger for a reload occurs; if the TC uses the prescaler, the counter in the prescaler should not have a value between zero and the division factor. The TC counter and the counter in the prescaler should both start at zero. When the counter is set to re-trigger when it reaches the maximum value on the other hand, this is not the right option to use. In such a case it would be better if the prescaler is left unaltered when the re-trigger happens, letting the counter reset on the next GCLK cycle.</p>
<h2><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match"></a>
Compare Match Operations</h2>
<p>In compare match operation, Compare/Capture registers are used in comparison with the counter value. When the timer's count value matches the value of a compare channel, a user defined action can be taken.</p>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_timer"></a>
Basic Timer</h3>
<p>A Basic Timer is a simple application where compare match operations are used to determine when a specific period has elapsed. In Basic Timer operations, one or more values in the module's Compare/Capture registers are used to specify the time (as a number of prescaled GCLK cycles) when an action should be taken by the microcontroller. This can be an Interrupt Service Routine (ISR), event generator via the event system, or a software flag that is polled via the user application.</p>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_wg"></a>
Waveform Generation</h3>
<p>Waveform generation enables the TC module to generate square waves, or if combined with an external passive low-pass filter; analog waveforms.</p>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_wg_pwm"></a>
Waveform Generation - PWM</h3>
<p>Pulse width modulation is a form of waveform generation and a signalling technique that can be useful in many situations. When PWM mode is used, a digital pulse train with a configurable frequency and duty cycle can be generated by the TC module and output to a GPIO pin of the device.</p>
<p>Often PWM is used to communicate a control or information parameter to an external circuit or component. Differing impedances of the source generator and sink receiver circuits are less of an issue when using PWM compared to using an analog voltage value, as noise will not generally affect the signal's integrity to a meaningful extent.</p>
<p><a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_module_pwm_normal_diag">The figure below</a> illustrates operations and different states of the counter and its output when running the counter in PWM normal mode. As can be seen, the TOP value is unchanged and is set to MAX. The compare match value is changed at several points to illustrate the resulting waveform output changes. The PWM output is set to normal (i.e. non-inverted) output mode.</p>
<p><a class="anchor" id="asfdoc_sam0_tc_module_pwm_normal_diag"></a> </p><div class="image">
<object type="image/svg+xml" data="pwm_normal_ex.svg">pwm_normal_ex.svg</object>
<div class="caption">
Example of PWM in Normal Mode, and Different Counter Operations</div></div>
<p>In <a class="el" href="group__asfdoc__sam0__tc__group.html#asfdoc_sam0_tc_module_pwm_match_diag">the figure below</a>, the counter is set to generate PWM in Match mode. The PWM output is inverted via the appropriate configuration option in the TC driver configuration structure. In this example, the counter value is changed once, but the compare match value is kept unchanged. As can be seen, it is possible to change the TOP value when running in PWM match mode.</p>
<p><a class="anchor" id="asfdoc_sam0_tc_module_pwm_match_diag"></a> </p><div class="image">
<object type="image/svg+xml" data="pwm_match_ex.svg">pwm_match_ex.svg</object>
<div class="caption">
Example of PWM in Match Mode and Different Counter Operations</div></div>
 <h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_wg_freq"></a>
Waveform Generation - Frequency</h3>
<p>Frequency Generation mode is in many ways identical to PWM generation. However, in Frequency Generation a toggle only occurs on the output when a match on a capture channels occurs. When the match is made, the timer value is reset, resulting in a variable frequency square wave with a fixed 50% duty cycle.</p>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_capt"></a>
Capture Operations</h3>
<p>In capture operations, any event from the event system or a pin change can trigger a capture of the counter value. This captured counter value can be used as a timestamp for the event, or it can be used in frequency and pulse width capture.</p>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_capt_event_capture"></a>
Capture Operations - Event</h3>
<p>Event capture is a simple use of the capture functionality, designed to create timestamps for specific events. When the TC module's input capture pin is externally toggled, the current timer count value is copied into a buffered register which can then be read out by the user application.</p>
<p>Note that when performing any capture operation, there is a risk that the counter reaches its top value (MAX) when counting up, or the bottom value (zero) when counting down, before the capture event occurs. This can distort the result, making event timestamps to appear shorter than reality; the user application should check for timer overflow when reading a capture result in order to detect this situation and perform an appropriate adjustment.</p>
<p>Before checking for a new capture, <a class="el" href="group__asfdoc__sam0__tc__group.html#gada6e9a6bd144c0c2e360d1fdef944cdd">TC_STATUS_COUNT_OVERFLOW</a> should be checked. The response to an overflow error is left to the user application, however it may be necessary to clear both the capture overflow flag and the capture flag upon each capture reading.</p>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_compare_match_capt_pwc"></a>
Capture Operations - Pulse Width</h3>
<p>Pulse Width Capture mode makes it possible to measure the pulse width and period of PWM signals. This mode uses two capture channels of the counter. This means that the counter module used for Pulse Width Capture can not be used for any other purpose. There are two modes for pulse width capture; Pulse Width Period (PWP) and Period Pulse Width (PPW). In PWP mode, capture channel 0 is used for storing the pulse width and capture channel 1 stores the observed period. While in PPW mode, the roles of the two capture channels are reversed.</p>
<p>As in the above example it is necessary to poll on interrupt flags to see if a new capture has happened and check that a capture overflow error has not occurred.</p>
<h2><a class="anchor" id="asfdoc_sam0_tc_module_overview_oneshot"></a>
One-shot Mode</h2>
<p>TC modules can be configured into a one-shot mode. When configured in this manner, starting the timer will cause it to count until the next overflow or underflow condition before automatically halting, waiting to be manually triggered by the user application software or an event signal from the event system.</p>
<h3><a class="anchor" id="asfdoc_sam0_tc_module_overview_inversion"></a>
Wave Generation Output Inversion</h3>
<p>The output of the wave generation can be inverted by hardware if desired, resulting in the logically inverted value being output to the configured device GPIO pin.</p>
<h1><a class="anchor" id="asfdoc_sam0_tc_special_considerations"></a>
Special Considerations</h1>
<p>The number of capture compare registers in each TC module is dependent on the specific SAM device being used, and in some cases the counter size.</p>
<p>The maximum amount of capture compare registers available in any SAM device is two when running in 32-bit mode and four in 8- and 16-bit modes.</p>
<h1><a class="anchor" id="asfdoc_sam0_tc_extra_info"></a>
Extra Information</h1>
<p>For extra information, see <a class="el" href="asfdoc_sam0_tc_extra.html">Extra Information for TC Driver</a>. This includes:</p><ul>
<li><a class="el" href="asfdoc_sam0_tc_extra.html#asfdoc_sam0_tc_extra_acronyms">Acronyms</a></li>
<li><a class="el" href="asfdoc_sam0_tc_extra.html#asfdoc_sam0_tc_extra_dependencies">Dependencies</a></li>
<li><a class="el" href="asfdoc_sam0_tc_extra.html#asfdoc_sam0_tc_extra_errata">Errata</a></li>
<li><a class="el" href="asfdoc_sam0_tc_extra.html#asfdoc_sam0_tc_extra_history">Module History</a></li>
</ul>
<h1><a class="anchor" id="asfdoc_sam0_tc_examples"></a>
Examples</h1>
<p>For a list of examples related to this driver, see <a class="el" href="asfdoc_sam0_tc_exqsg.html">Examples for TC Driver</a>.</p>
<h1><a class="anchor" id="asfdoc_sam0_tc_api_overview"></a>
API Overview</h1>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="gac837f9db5df1793578c195a979c6a9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac837f9db5df1793578c195a979c6a9d3">&#9670;&nbsp;</a></span>NUMBER_OF_COMPARE_CAPTURE_CHANNELS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NUMBER_OF_COMPARE_CAPTURE_CHANNELS&#160;&#160;&#160;<a class="el" href="tc3_8h.html#a2d4adcedec07af5cc0519e42d1bf2180">TC3_CC8_NUM</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define port features set according to different device family </p>

</div>
</div>
<a id="ga94cdbe531468f0975311bc2ce36f5e1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94cdbe531468f0975311bc2ce36f5e1c">&#9670;&nbsp;</a></span>TC_INST_MAX_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TC_INST_MAX_ID&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TC Instance MAX ID Number. </p>

</div>
</div>
<a id="gac13395d51cc03b5c43eda7654649925f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac13395d51cc03b5c43eda7654649925f">&#9670;&nbsp;</a></span>TC_STATUS_CAPTURE_OVERFLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TC_STATUS_CAPTURE_OVERFLOW&#160;&#160;&#160;(1UL &lt;&lt; 3)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A new value was captured before the previous value was read, resulting in lost data. </p>

</div>
</div>
<a id="gae74e90dac05478452203a41a88853286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae74e90dac05478452203a41a88853286">&#9670;&nbsp;</a></span>TC_STATUS_CHANNEL_0_MATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TC_STATUS_CHANNEL_0_MATCH&#160;&#160;&#160;(1UL &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer channel 0 has matched against its compare value, or has captured a new value. </p>

</div>
</div>
<a id="gaab140d8ac7858f45029fddf0fd3f4cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab140d8ac7858f45029fddf0fd3f4cf3">&#9670;&nbsp;</a></span>TC_STATUS_CHANNEL_1_MATCH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TC_STATUS_CHANNEL_1_MATCH&#160;&#160;&#160;(1UL &lt;&lt; 1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer channel 1 has matched against its compare value, or has captured a new value. </p>

</div>
</div>
<a id="gada6e9a6bd144c0c2e360d1fdef944cdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada6e9a6bd144c0c2e360d1fdef944cdd">&#9670;&nbsp;</a></span>TC_STATUS_COUNT_OVERFLOW</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TC_STATUS_COUNT_OVERFLOW&#160;&#160;&#160;(1UL &lt;&lt; 4)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The timer count value has overflowed from its maximum value to its minimum when counting upward, or from its minimum value to its maximum when counting downward. </p>

</div>
</div>
<a id="ga73bfbe04c8834ec55242bcd0b678f94e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73bfbe04c8834ec55242bcd0b678f94e">&#9670;&nbsp;</a></span>TC_STATUS_SYNC_READY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TC_STATUS_SYNC_READY&#160;&#160;&#160;(1UL &lt;&lt; 2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Timer register synchronization has completed, and the synchronized count value may be read. </p>

</div>
</div>
<a id="ga65ebbd3eaea3bd9cf6f81392770caae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65ebbd3eaea3bd9cf6f81392770caae6">&#9670;&nbsp;</a></span>TC_WAVE_GENERATION_MATCH_FREQ_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TC_WAVE_GENERATION_MATCH_FREQ_MODE&#160;&#160;&#160;<a class="el" href="group___s_a_m_d21___t_c.html#ga481c00b2ec0ab62d5c321b1f3fb32493">TC_CTRLA_WAVEGEN_MFRQ</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TC wave generation mode: match frequency. </p>

</div>
</div>
<a id="ga4636ecc5d5a67c47a8b6551568c31ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4636ecc5d5a67c47a8b6551568c31ee6">&#9670;&nbsp;</a></span>TC_WAVE_GENERATION_MATCH_PWM_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TC_WAVE_GENERATION_MATCH_PWM_MODE&#160;&#160;&#160;<a class="el" href="group___s_a_m_d21___t_c.html#gac9b02e2cfc519e0fc97c3b89efdc7be1">TC_CTRLA_WAVEGEN_MPWM</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TC wave generation mode: match PWM. </p>

</div>
</div>
<a id="ga3be501afca9dd97d2adb1959f30816a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3be501afca9dd97d2adb1959f30816a7">&#9670;&nbsp;</a></span>TC_WAVE_GENERATION_NORMAL_FREQ_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TC_WAVE_GENERATION_NORMAL_FREQ_MODE&#160;&#160;&#160;<a class="el" href="group___s_a_m_d21___t_c.html#ga3d7b144f5e197d57332ab754b75b12c9">TC_CTRLA_WAVEGEN_NFRQ</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TC wave generation mode: normal frequency. </p>

</div>
</div>
<a id="gaa7277c5eaa031dbd06159cd533346210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa7277c5eaa031dbd06159cd533346210">&#9670;&nbsp;</a></span>TC_WAVE_GENERATION_NORMAL_PWM_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TC_WAVE_GENERATION_NORMAL_PWM_MODE&#160;&#160;&#160;<a class="el" href="group___s_a_m_d21___t_c.html#ga74de3c0bcf4adf87189c90b28cd7310d">TC_CTRLA_WAVEGEN_NPWM</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TC wave generation mode: normal PWM. </p>

</div>
</div>
<a id="ga50cb4d965dd6d607839abb71b3f034c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga50cb4d965dd6d607839abb71b3f034c0">&#9670;&nbsp;</a></span>TC_WAVEFORM_INVERT_CC0_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TC_WAVEFORM_INVERT_CC0_MODE&#160;&#160;&#160;<a class="el" href="group___s_a_m_d21___t_c.html#gabcaa416dc792b45f9ea315455d3ab4c0">TC_CTRLC_INVEN</a>(1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waveform inversion CC0 mode. </p>

</div>
</div>
<a id="gae194715d12d4faa15f1d1b8555bf5b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae194715d12d4faa15f1d1b8555bf5b53">&#9670;&nbsp;</a></span>TC_WAVEFORM_INVERT_CC1_MODE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TC_WAVEFORM_INVERT_CC1_MODE&#160;&#160;&#160;<a class="el" href="group___s_a_m_d21___t_c.html#gabcaa416dc792b45f9ea315455d3ab4c0">TC_CTRLC_INVEN</a>(2)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waveform inversion CC1 mode. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga2a1d57f42085001f29a6584ae8ab1bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2a1d57f42085001f29a6584ae8ab1bb4">&#9670;&nbsp;</a></span>tc_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* tc_callback_t) (struct <a class="el" href="structtc__module.html">tc_module</a> *const module)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of the callback functions. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga7d3fb5365e46bd4efae2885bd508067f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d3fb5365e46bd4efae2885bd508067f">&#9670;&nbsp;</a></span>tc_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga7d3fb5365e46bd4efae2885bd508067f">tc_callback</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum for the possible callback types for the TC module. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga7d3fb5365e46bd4efae2885bd508067fade9a99ec0d7386cfff45671de03b8b6a"></a>TC_CALLBACK_OVERFLOW&#160;</td><td class="fielddoc"><p>Callback for TC overflow </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d3fb5365e46bd4efae2885bd508067fab6fb975aff8c4ace0dbece4bf825332b"></a>TC_CALLBACK_ERROR&#160;</td><td class="fielddoc"><p>Callback for capture overflow error </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d3fb5365e46bd4efae2885bd508067fa03e7143b9984e00ad432db650abd69c6"></a>TC_CALLBACK_CC_CHANNEL0&#160;</td><td class="fielddoc"><p>Callback for capture compare channel 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d3fb5365e46bd4efae2885bd508067fae16450d1f8ef97cc1b129524b72efdf3"></a>TC_CALLBACK_CC_CHANNEL1&#160;</td><td class="fielddoc"><p>Callback for capture compare channel 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga7d3fb5365e46bd4efae2885bd508067faf76c479c366d3c15450245bb4ee9a856"></a>TC_CALLBACK_N&#160;</td><td class="fielddoc"><p>Number of available callbacks </p>
</td></tr>
</table>

</div>
</div>
<a id="ga98aed17b995157e67b9322a45f0ed5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98aed17b995157e67b9322a45f0ed5f4">&#9670;&nbsp;</a></span>tc_clock_prescaler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga98aed17b995157e67b9322a45f0ed5f4">tc_clock_prescaler</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TC clock prescaler values. </p>
<p>This enum is used to choose the clock prescaler configuration. The prescaler divides the clock frequency of the TC module to make the counter count slower. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga98aed17b995157e67b9322a45f0ed5f4abee76ee986e815120c67ff104dd77275"></a>TC_CLOCK_PRESCALER_DIV1&#160;</td><td class="fielddoc"><p>Divide clock by 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga98aed17b995157e67b9322a45f0ed5f4a6326eb4305153ea58ea18ee6a74bc8f0"></a>TC_CLOCK_PRESCALER_DIV2&#160;</td><td class="fielddoc"><p>Divide clock by 2 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga98aed17b995157e67b9322a45f0ed5f4a8c137a94b34809e544d50680c808da23"></a>TC_CLOCK_PRESCALER_DIV4&#160;</td><td class="fielddoc"><p>Divide clock by 4 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga98aed17b995157e67b9322a45f0ed5f4a3dbb4f263ba1e940954ffe8a667bf7d1"></a>TC_CLOCK_PRESCALER_DIV8&#160;</td><td class="fielddoc"><p>Divide clock by 8 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga98aed17b995157e67b9322a45f0ed5f4aa0bec32bcf9a450d950f9ec9941a6c3a"></a>TC_CLOCK_PRESCALER_DIV16&#160;</td><td class="fielddoc"><p>Divide clock by 16 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga98aed17b995157e67b9322a45f0ed5f4aea8fd1d9e795ec153e80cddc15ad501b"></a>TC_CLOCK_PRESCALER_DIV64&#160;</td><td class="fielddoc"><p>Divide clock by 64 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga98aed17b995157e67b9322a45f0ed5f4a72552d0e6095d90da22981b7bd7a33ed"></a>TC_CLOCK_PRESCALER_DIV256&#160;</td><td class="fielddoc"><p>Divide clock by 256 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga98aed17b995157e67b9322a45f0ed5f4af1540c54586b7cd0c5e46c60162951ec"></a>TC_CLOCK_PRESCALER_DIV1024&#160;</td><td class="fielddoc"><p>Divide clock by 1024 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga01eca97dbfd588fd3ba0dcfd4792d857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01eca97dbfd588fd3ba0dcfd4792d857">&#9670;&nbsp;</a></span>tc_compare_capture_channel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga01eca97dbfd588fd3ba0dcfd4792d857">tc_compare_capture_channel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Index of the compare capture channels. </p>
<p>This enum is used to specify which capture/compare channel to do operations on. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga01eca97dbfd588fd3ba0dcfd4792d857a5f6651d829a75778a759ce5a519b76a4"></a>TC_COMPARE_CAPTURE_CHANNEL_0&#160;</td><td class="fielddoc"><p>Index of compare capture channel 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga01eca97dbfd588fd3ba0dcfd4792d857a8fcf38e3b831977347028475b5583141"></a>TC_COMPARE_CAPTURE_CHANNEL_1&#160;</td><td class="fielddoc"><p>Index of compare capture channel 1 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga28777c47943dfb2b5de0fd7ae14eac1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28777c47943dfb2b5de0fd7ae14eac1f">&#9670;&nbsp;</a></span>tc_count_direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga28777c47943dfb2b5de0fd7ae14eac1f">tc_count_direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TC module count direction. </p>
<p>Timer/Counter count direction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga28777c47943dfb2b5de0fd7ae14eac1faf247abdaef160b832fd09bc7597e8ca3"></a>TC_COUNT_DIRECTION_UP&#160;</td><td class="fielddoc"><p>Timer should count upward from zero to MAX </p>
</td></tr>
<tr><td class="fieldname"><a id="gga28777c47943dfb2b5de0fd7ae14eac1fade3defd512c1bff05ce6302c2d96b014"></a>TC_COUNT_DIRECTION_DOWN&#160;</td><td class="fielddoc"><p>Timer should count downward to zero from MAX </p>
</td></tr>
</table>

</div>
</div>
<a id="ga1b112627b81227c49c16b1a93e3321a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b112627b81227c49c16b1a93e3321a0">&#9670;&nbsp;</a></span>tc_counter_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga1b112627b81227c49c16b1a93e3321a0">tc_counter_size</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specifies if the counter is 8-, 16-, or 32-bit. </p>
<p>This enum specifies the maximum value it is possible to count to. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga1b112627b81227c49c16b1a93e3321a0abf2e8000eeeac2a4f259ba117d1ee934"></a>TC_COUNTER_SIZE_8BIT&#160;</td><td class="fielddoc"><p>The counter's maximum value is 0xFF, the period register is available to be used as top value </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1b112627b81227c49c16b1a93e3321a0a07c9fe9d2a5e78a9c1be46ce540adad1"></a>TC_COUNTER_SIZE_16BIT&#160;</td><td class="fielddoc"><p>The counter's maximum value is 0xFFFF. There is no separate period register, to modify top one of the capture compare registers has to be used. This limits the amount of available channels. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga1b112627b81227c49c16b1a93e3321a0a7d28e63b11a550605d003c894fe134c5"></a>TC_COUNTER_SIZE_32BIT&#160;</td><td class="fielddoc"><p>The counter's maximum value is 0xFFFFFFFF. There is no separate period register, to modify top one of the capture compare registers has to be used. This limits the amount of available channels. </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4dcbf6cdb74bc3b7609ce8d16549462f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4dcbf6cdb74bc3b7609ce8d16549462f">&#9670;&nbsp;</a></span>tc_event_action</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga4dcbf6cdb74bc3b7609ce8d16549462f">tc_event_action</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Action to perform when the TC module is triggered by an event. </p>
<p>Event action to perform when the module is triggered by an event. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4dcbf6cdb74bc3b7609ce8d16549462fa190e10df25f3f6a6c781cc751eb3489e"></a>TC_EVENT_ACTION_OFF&#160;</td><td class="fielddoc"><p>No event action </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4dcbf6cdb74bc3b7609ce8d16549462fa9696961ae81b1aba22582d8a35bdf14d"></a>TC_EVENT_ACTION_RETRIGGER&#160;</td><td class="fielddoc"><p>Re-trigger on event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4dcbf6cdb74bc3b7609ce8d16549462fa07b969496782cb311ddb13cfafb36aff"></a>TC_EVENT_ACTION_INCREMENT_COUNTER&#160;</td><td class="fielddoc"><p>Increment counter on event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4dcbf6cdb74bc3b7609ce8d16549462fac06c64382b572d0464138ae51b7876df"></a>TC_EVENT_ACTION_START&#160;</td><td class="fielddoc"><p>Start counter on event </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4dcbf6cdb74bc3b7609ce8d16549462fa4957024d607401030b128f9b775edb7d"></a>TC_EVENT_ACTION_PPW&#160;</td><td class="fielddoc"><p>Store period in capture register 0, pulse width in capture register 1 </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4dcbf6cdb74bc3b7609ce8d16549462face22a0756d93b16a9b70511fe226a893"></a>TC_EVENT_ACTION_PWP&#160;</td><td class="fielddoc"><p>Store pulse width in capture register 0, period in capture register 1 </p>
</td></tr>
</table>

</div>
</div>
<a id="ga204bb4814c91e62e56d9297c05280aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga204bb4814c91e62e56d9297c05280aad">&#9670;&nbsp;</a></span>tc_reload_action</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga204bb4814c91e62e56d9297c05280aad">tc_reload_action</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TC Counter reload action enum. </p>
<p>This enum specify how the counter and prescaler should reload. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga204bb4814c91e62e56d9297c05280aadaea50b7d7b79cfbd72298720e0f6d51ed"></a>TC_RELOAD_ACTION_GCLK&#160;</td><td class="fielddoc"><p>The counter is reloaded/reset on the next GCLK and starts counting on the prescaler clock </p>
</td></tr>
<tr><td class="fieldname"><a id="gga204bb4814c91e62e56d9297c05280aada97857fba0947beb9110ab79d2990e559"></a>TC_RELOAD_ACTION_PRESC&#160;</td><td class="fielddoc"><p>The counter is reloaded/reset on the next prescaler clock </p>
</td></tr>
<tr><td class="fieldname"><a id="gga204bb4814c91e62e56d9297c05280aadac78b7c50f80b33d5ef15a63348279f17"></a>TC_RELOAD_ACTION_RESYNC&#160;</td><td class="fielddoc"><p>The counter is reloaded/reset on the next GCLK, and the prescaler is restarted as well </p>
</td></tr>
</table>

</div>
</div>
<a id="gae7f1302b7e3d675e471a554668b49d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7f1302b7e3d675e471a554668b49d64">&#9670;&nbsp;</a></span>tc_wave_generation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#gae7f1302b7e3d675e471a554668b49d64">tc_wave_generation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TC wave generation mode enum. </p>
<p>This enum is used to select which mode to run the wave generation in. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggae7f1302b7e3d675e471a554668b49d64a544e51b015f20263a9499ce28a0596e7"></a>TC_WAVE_GENERATION_NORMAL_FREQ&#160;</td><td class="fielddoc"><p>Top is maximum, except in 8-bit counter size where it is the PER register </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae7f1302b7e3d675e471a554668b49d64a4c9b3fe1ad9a1d2c0f5d8544c0923b9f"></a>TC_WAVE_GENERATION_MATCH_FREQ&#160;</td><td class="fielddoc"><p>Top is CC0, except in 8-bit counter size where it is the PER register </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae7f1302b7e3d675e471a554668b49d64aad9dc196250ce8ca5a98c7e49cf0c1a9"></a>TC_WAVE_GENERATION_NORMAL_PWM&#160;</td><td class="fielddoc"><p>Top is maximum, except in 8-bit counter size where it is the PER register </p>
</td></tr>
<tr><td class="fieldname"><a id="ggae7f1302b7e3d675e471a554668b49d64a973273609713f828ce491f56fbf035d2"></a>TC_WAVE_GENERATION_MATCH_PWM&#160;</td><td class="fielddoc"><p>Top is CC0, except in 8-bit counter size where it is the PER register </p>
</td></tr>
</table>

</div>
</div>
<a id="gaf681729d6b5f963705871f7d80754166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf681729d6b5f963705871f7d80754166">&#9670;&nbsp;</a></span>tc_waveform_invert_output</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__tc__group.html#gaf681729d6b5f963705871f7d80754166">tc_waveform_invert_output</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waveform inversion mode. </p>
<p>Output waveform inversion mode. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggaf681729d6b5f963705871f7d80754166a292cfce35b768eecd69f2a4320aaa96b"></a>TC_WAVEFORM_INVERT_OUTPUT_NONE&#160;</td><td class="fielddoc"><p>No inversion of the waveform output </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf681729d6b5f963705871f7d80754166af3ebe1706d0f442c6388619bc3d9fa58"></a>TC_WAVEFORM_INVERT_OUTPUT_CHANNEL_0&#160;</td><td class="fielddoc"><p>Invert output from compare channel 0 </p>
</td></tr>
<tr><td class="fieldname"><a id="ggaf681729d6b5f963705871f7d80754166a97327e36339fbad207e7150d6ba7b283"></a>TC_WAVEFORM_INVERT_OUTPUT_CHANNEL_1&#160;</td><td class="fielddoc"><p>Invert output from compare channel 1 </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga077a238b03327682013a0bceb4fc44b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga077a238b03327682013a0bceb4fc44b2">&#9670;&nbsp;</a></span>_tc_get_inst_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t _tc_get_inst_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_tc.html">Tc</a> *const&#160;</td>
          <td class="paramname"><em>hw</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaf780bb09a00298868aa3b8e7627f92ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf780bb09a00298868aa3b8e7627f92ff">&#9670;&nbsp;</a></span>tc_get_capture_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tc_get_capture_value </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtc__module.html">tc_module</a> *const&#160;</td>
          <td class="paramname"><em>module_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga01eca97dbfd588fd3ba0dcfd4792d857">tc_compare_capture_channel</a>&#160;</td>
          <td class="paramname"><em>channel_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the TC module capture value. </p>
<p>Retrieves the capture value in the indicated TC module capture channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module_inst</td><td>Pointer to the software module instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_index</td><td>Index of the Compare Capture channel to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Capture value stored in the specified timer channel. </dd></dl>

</div>
</div>
<a id="gae7d7eb91616c2dff02886dd8cdc87f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7d7eb91616c2dff02886dd8cdc87f2d">&#9670;&nbsp;</a></span>tc_get_count_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t tc_get_count_value </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtc__module.html">tc_module</a> *const&#160;</td>
          <td class="paramname"><em>module_inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get TC module count value. </p>
<p>Retrieves the current count value of a TC module. The specified TC module may be started or stopped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module_inst</td><td>Pointer to the software module instance struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Count value of the specified TC module. </dd></dl>

</div>
</div>
<a id="ga98c7f5c97436c2f6cff87a0261597337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98c7f5c97436c2f6cff87a0261597337">&#9670;&nbsp;</a></span>tc_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> tc_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structtc__module.html">tc_module</a> *const&#160;</td>
          <td class="paramname"><em>module_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_tc.html">Tc</a> *const&#160;</td>
          <td class="paramname"><em>hw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structtc__config.html">tc_config</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a hardware TC module instance. </p>
<p>Enables the clock and initializes the TC module, based on the given configuration values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module_inst</td><td>Pointer to the software module instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hw</td><td>Pointer to the TC hardware module </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to the TC configuration options struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the initialization procedure.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>The module was initialized successfully </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>Hardware module was busy when the initialization procedure was attempted </td></tr>
    <tr><td class="paramname">STATUS_INVALID_ARG</td><td>An invalid configuration option or argument was supplied </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>Hardware module was already enabled, or the hardware module is configured in 32-bit slave mode </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad147c1f0393a3ae0c830cec73986eddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad147c1f0393a3ae0c830cec73986eddd">&#9670;&nbsp;</a></span>tc_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> tc_reset </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtc__module.html">tc_module</a> *const&#160;</td>
          <td class="paramname"><em>module_inst</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the TC module. </p>
<p>Resets the TC module, restoring all hardware module registers to their default values and disabling the module. The TC module will not be accessible while the reset is being performed.</p>
<dl class="section note"><dt>Note</dt><dd>When resetting a 32-bit counter only the master TC module's instance structure should be passed to the function.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module_inst</td><td>Pointer to the software module instance struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the procedure. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>The module was reset successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_UNSUPPORTED_DEV</td><td>A 32-bit slave TC module was passed to the function. Only use reset on master TC </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga687208b24fd33a1da0cbe683adc15fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga687208b24fd33a1da0cbe683adc15fa6">&#9670;&nbsp;</a></span>tc_set_compare_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> tc_set_compare_value </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtc__module.html">tc_module</a> *const&#160;</td>
          <td class="paramname"><em>module_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const enum <a class="el" href="group__asfdoc__sam0__tc__group.html#ga01eca97dbfd588fd3ba0dcfd4792d857">tc_compare_capture_channel</a>&#160;</td>
          <td class="paramname"><em>channel_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a TC module compare value. </p>
<p>Writes a compare value to the given TC module compare/capture channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module_inst</td><td>Pointer to the software module instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">channel_index</td><td>Index of the compare channel to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">compare</td><td>New compare value to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the compare update procedure.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>The compare value was updated successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>An invalid channel index was supplied </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9c81066b0b88893e127fa521f0efde2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c81066b0b88893e127fa521f0efde2e">&#9670;&nbsp;</a></span>tc_set_count_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> tc_set_count_value </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtc__module.html">tc_module</a> *const&#160;</td>
          <td class="paramname"><em>module_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets TC module count value. </p>
<p>Sets the current timer count value of a initialized TC module. The specified TC module may be started or stopped.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module_inst</td><td>Pointer to the software module instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>New timer count value to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the count update procedure.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>The timer count was updated successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>An invalid timer counter size was specified </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gac22d633ece43bcd18f54283778471340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac22d633ece43bcd18f54283778471340">&#9670;&nbsp;</a></span>tc_set_top_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> tc_set_top_value </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structtc__module.html">tc_module</a> *const&#160;</td>
          <td class="paramname"><em>module_inst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>top_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the timer TOP/period value. </p>
<p>For 8-bit counter size this function writes the top value to the period register.</p>
<p>For 16- and 32-bit counter size this function writes the top value to Capture Compare register 0. The value in this register can not be used for any other purpose.</p>
<dl class="section note"><dt>Note</dt><dd>This function is designed to be used in PWM or frequency match modes only, when the counter is set to 16- or 32-bit counter size. In 8-bit counter size it will always be possible to change the top value even in normal mode.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">module_inst</td><td>Pointer to the software module instance struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">top_value</td><td>New timer TOP value to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of the TOP set procedure.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>The timer TOP value was updated successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_INVALID_ARG</td><td>The configured TC module counter size in the module instance is invalid </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
