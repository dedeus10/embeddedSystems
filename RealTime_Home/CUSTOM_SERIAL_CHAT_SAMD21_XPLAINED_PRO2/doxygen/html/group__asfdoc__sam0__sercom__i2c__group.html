<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RealTime_Home: Asfdoc_sam0_sercom_i2c_group</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RealTime_Home
   &#160;<span id="projectnumber">2.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__asfdoc__sam0__sercom__i2c__group.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">Asfdoc_sam0_sercom_i2c_group</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__master__packet.html">i2c_master_packet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">I<sup>2</sup>C master packet for read/write.  <a href="structi2c__master__packet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__master__module.html">i2c_master_module</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SERCOM I<sup>2</sup>C Master driver software device instance structure.  <a href="structi2c__master__module.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structi2c__master__config.html">i2c_master_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration structure for the I<sup>2</sup>C Master device.  <a href="structi2c__master__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga0ef653593dbacc01735c61e59ec3f0da"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga0ef653593dbacc01735c61e59ec3f0da">i2c_master_callback_t</a>) (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module)</td></tr>
<tr class="separator:ga0ef653593dbacc01735c61e59ec3f0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga9f73c4fbd225704c2e0da23319c25555"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga9f73c4fbd225704c2e0da23319c25555">i2c_master_interrupt_flag</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga9f73c4fbd225704c2e0da23319c25555a39c138d5f063f3d43b4e974870364d2e">I2C_MASTER_INTERRUPT_WRITE</a> = 0, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga9f73c4fbd225704c2e0da23319c25555a3087032aa3a5218a0cdc54179d9e1d09">I2C_MASTER_INTERRUPT_READ</a> = 1
 }</td></tr>
<tr class="memdesc:ga9f73c4fbd225704c2e0da23319c25555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt flags.  <a href="group__asfdoc__sam0__sercom__i2c__group.html#ga9f73c4fbd225704c2e0da23319c25555">More...</a><br /></td></tr>
<tr class="separator:ga9f73c4fbd225704c2e0da23319c25555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd8aa7cabbddc1cd2c1a8753c9b99d20"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gadd8aa7cabbddc1cd2c1a8753c9b99d20">i2c_master_start_hold_time</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggadd8aa7cabbddc1cd2c1a8753c9b99d20a85f0b592eef5f8b5ecae9f2cca2d4cd1">I2C_MASTER_START_HOLD_TIME_DISABLED</a> = SERCOM_I2CM_CTRLA_SDAHOLD(0), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggadd8aa7cabbddc1cd2c1a8753c9b99d20a41403c4a18a1220f031c99e52f384e39">I2C_MASTER_START_HOLD_TIME_50NS_100NS</a> = SERCOM_I2CM_CTRLA_SDAHOLD(1), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggadd8aa7cabbddc1cd2c1a8753c9b99d20acc3f7849862510590acc2e3bebc29d0c">I2C_MASTER_START_HOLD_TIME_300NS_600NS</a> = SERCOM_I2CM_CTRLA_SDAHOLD(2), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggadd8aa7cabbddc1cd2c1a8753c9b99d20a38cf380ace8d180528eb34bc38b7da9e">I2C_MASTER_START_HOLD_TIME_400NS_800NS</a> = SERCOM_I2CM_CTRLA_SDAHOLD(3)
 }</td></tr>
<tr class="memdesc:gadd8aa7cabbddc1cd2c1a8753c9b99d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values for hold time after start bit.  <a href="group__asfdoc__sam0__sercom__i2c__group.html#gadd8aa7cabbddc1cd2c1a8753c9b99d20">More...</a><br /></td></tr>
<tr class="separator:gadd8aa7cabbddc1cd2c1a8753c9b99d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4640bee224bf835f4c38d7702be0742c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga4640bee224bf835f4c38d7702be0742c">i2c_master_inactive_timeout</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga4640bee224bf835f4c38d7702be0742ca52414c5127a26a6811f30324102cc3b1">I2C_MASTER_INACTIVE_TIMEOUT_DISABLED</a> = SERCOM_I2CM_CTRLA_INACTOUT(0), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga4640bee224bf835f4c38d7702be0742ca9e204c432b52e77b4d34a5b64d4432e9">I2C_MASTER_INACTIVE_TIMEOUT_55US</a> = SERCOM_I2CM_CTRLA_INACTOUT(1), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga4640bee224bf835f4c38d7702be0742ca9f37beb962cccc4538b0c226c921c553">I2C_MASTER_INACTIVE_TIMEOUT_105US</a> = SERCOM_I2CM_CTRLA_INACTOUT(2), 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga4640bee224bf835f4c38d7702be0742ca7412f98fd47572a75dc17727fdf735d0">I2C_MASTER_INACTIVE_TIMEOUT_205US</a> = SERCOM_I2CM_CTRLA_INACTOUT(3)
 }</td></tr>
<tr class="memdesc:ga4640bee224bf835f4c38d7702be0742c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Values for inactive bus time-out.  <a href="group__asfdoc__sam0__sercom__i2c__group.html#ga4640bee224bf835f4c38d7702be0742c">More...</a><br /></td></tr>
<tr class="separator:ga4640bee224bf835f4c38d7702be0742c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace1e0023f2eee92565496a2e30006548"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gace1e0023f2eee92565496a2e30006548">i2c_master_baud_rate</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggace1e0023f2eee92565496a2e30006548a24ddfbe034a690d3a553a17508cbd625">I2C_MASTER_BAUD_RATE_100KHZ</a> = 100, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ggace1e0023f2eee92565496a2e30006548a970dccbbc3dd1d01c1070db6d9aa24cb">I2C_MASTER_BAUD_RATE_400KHZ</a> = 400
 }</td></tr>
<tr class="memdesc:gace1e0023f2eee92565496a2e30006548"><td class="mdescLeft">&#160;</td><td class="mdescRight">I<sup>2</sup>C frequencies.  <a href="group__asfdoc__sam0__sercom__i2c__group.html#gace1e0023f2eee92565496a2e30006548">More...</a><br /></td></tr>
<tr class="separator:gace1e0023f2eee92565496a2e30006548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga844ac2694772642cfee08a29c50bf054"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga844ac2694772642cfee08a29c50bf054">i2c_master_callback</a> { <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga844ac2694772642cfee08a29c50bf054a37c3aab3ceb2bddf4b42672386fd64f2">I2C_MASTER_CALLBACK_WRITE_COMPLETE</a> = 0, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga844ac2694772642cfee08a29c50bf054a64edbb1496288626e11b020a887ffcf8">I2C_MASTER_CALLBACK_READ_COMPLETE</a> = 1, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga844ac2694772642cfee08a29c50bf054a97597905a886849275665273da79442f">I2C_MASTER_CALLBACK_ERROR</a> = 2, 
<a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gga844ac2694772642cfee08a29c50bf054a3563390afb1b1b26a6252e0b5981ed06">_I2C_MASTER_CALLBACK_N</a> = 3
 }</td></tr>
<tr class="memdesc:ga844ac2694772642cfee08a29c50bf054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback types.  <a href="group__asfdoc__sam0__sercom__i2c__group.html#ga844ac2694772642cfee08a29c50bf054">More...</a><br /></td></tr>
<tr class="separator:ga844ac2694772642cfee08a29c50bf054"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Configuration and Initialization</h2></td></tr>
<tr class="memitem:ga1c174d923b525f6d60402f66bc9c3451"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga1c174d923b525f6d60402f66bc9c3451">i2c_master_init</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, <a class="el" href="union_sercom.html">Sercom</a> *const hw, const struct <a class="el" href="structi2c__master__config.html">i2c_master_config</a> *const config)</td></tr>
<tr class="memdesc:ga1c174d923b525f6d60402f66bc9c3451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the requested I<sup>2</sup>C hardware module.  <a href="#ga1c174d923b525f6d60402f66bc9c3451">More...</a><br /></td></tr>
<tr class="separator:ga1c174d923b525f6d60402f66bc9c3451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc5e9982ce4d7c6acc68cb69c57883d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga6dc5e9982ce4d7c6acc68cb69c57883d">i2c_master_reset</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module)</td></tr>
<tr class="memdesc:ga6dc5e9982ce4d7c6acc68cb69c57883d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the hardware module.  <a href="#ga6dc5e9982ce4d7c6acc68cb69c57883d">More...</a><br /></td></tr>
<tr class="separator:ga6dc5e9982ce4d7c6acc68cb69c57883d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Read and Write</h2></td></tr>
<tr class="memitem:ga238a755f972b9c3287131cda5fc25725"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga238a755f972b9c3287131cda5fc25725">i2c_master_read_packet_wait</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr class="memdesc:ga238a755f972b9c3287131cda5fc25725"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data packet from slave.  <a href="#ga238a755f972b9c3287131cda5fc25725">More...</a><br /></td></tr>
<tr class="separator:ga238a755f972b9c3287131cda5fc25725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa8b27eb9e3a8ae0f907bf7078d4001f0"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gaa8b27eb9e3a8ae0f907bf7078d4001f0">i2c_master_read_packet_wait_no_stop</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr class="memdesc:gaa8b27eb9e3a8ae0f907bf7078d4001f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data packet from slave without sending a stop condition when done.  <a href="#gaa8b27eb9e3a8ae0f907bf7078d4001f0">More...</a><br /></td></tr>
<tr class="separator:gaa8b27eb9e3a8ae0f907bf7078d4001f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c07057fe2534e8b4a3ce2cfe2dafc1b"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga6c07057fe2534e8b4a3ce2cfe2dafc1b">i2c_master_write_packet_wait</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr class="memdesc:ga6c07057fe2534e8b4a3ce2cfe2dafc1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data packet to slave.  <a href="#ga6c07057fe2534e8b4a3ce2cfe2dafc1b">More...</a><br /></td></tr>
<tr class="separator:ga6c07057fe2534e8b4a3ce2cfe2dafc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d874599c2bff10cd08f5474041c66bb"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga4d874599c2bff10cd08f5474041c66bb">i2c_master_write_packet_wait_no_stop</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr class="memdesc:ga4d874599c2bff10cd08f5474041c66bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data packet to slave without sending a stop condition when done.  <a href="#ga4d874599c2bff10cd08f5474041c66bb">More...</a><br /></td></tr>
<tr class="separator:ga4d874599c2bff10cd08f5474041c66bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bddf9e717847b5fa8462596e7e1489c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga6bddf9e717847b5fa8462596e7e1489c">i2c_master_send_stop</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module)</td></tr>
<tr class="memdesc:ga6bddf9e717847b5fa8462596e7e1489c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends stop condition on bus.  <a href="#ga6bddf9e717847b5fa8462596e7e1489c">More...</a><br /></td></tr>
<tr class="separator:ga6bddf9e717847b5fa8462596e7e1489c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9bb3b3174c1fc602c3097bc40eadcef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gaf9bb3b3174c1fc602c3097bc40eadcef">i2c_master_send_nack</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module)</td></tr>
<tr class="memdesc:gaf9bb3b3174c1fc602c3097bc40eadcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends nack signal on bus.  <a href="#gaf9bb3b3174c1fc602c3097bc40eadcef">More...</a><br /></td></tr>
<tr class="separator:gaf9bb3b3174c1fc602c3097bc40eadcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54cf79ca8aa80e2163881ca4164e35f7"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga54cf79ca8aa80e2163881ca4164e35f7">i2c_master_read_byte</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, uint8_t *byte)</td></tr>
<tr class="memdesc:ga54cf79ca8aa80e2163881ca4164e35f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads one byte data from slave.  <a href="#ga54cf79ca8aa80e2163881ca4164e35f7">More...</a><br /></td></tr>
<tr class="separator:ga54cf79ca8aa80e2163881ca4164e35f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2de09ec9474331f354eec703b80b6e"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gaee2de09ec9474331f354eec703b80b6e">i2c_master_write_byte</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, uint8_t byte)</td></tr>
<tr class="memdesc:gaee2de09ec9474331f354eec703b80b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write one byte data to slave.  <a href="#gaee2de09ec9474331f354eec703b80b6e">More...</a><br /></td></tr>
<tr class="separator:gaee2de09ec9474331f354eec703b80b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae39b9f208966b0857f0bb61dc4dffd83"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gae39b9f208966b0857f0bb61dc4dffd83">i2c_master_read_packet_wait_no_nack</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr class="separator:gae39b9f208966b0857f0bb61dc4dffd83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Callbacks</h2></td></tr>
<tr class="memitem:ga5ba2356881237729e03a8c4637b96306"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga5ba2356881237729e03a8c4637b96306">_i2c_master_interrupt_handler</a> (uint8_t instance)</td></tr>
<tr class="separator:ga5ba2356881237729e03a8c4637b96306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3216a045490437ec87ba14ffeee5e7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gaf3216a045490437ec87ba14ffeee5e7b">i2c_master_register_callback</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga0ef653593dbacc01735c61e59ec3f0da">i2c_master_callback_t</a> callback, enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga844ac2694772642cfee08a29c50bf054">i2c_master_callback</a> callback_type)</td></tr>
<tr class="memdesc:gaf3216a045490437ec87ba14ffeee5e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers callback for the specified callback type.  <a href="#gaf3216a045490437ec87ba14ffeee5e7b">More...</a><br /></td></tr>
<tr class="separator:gaf3216a045490437ec87ba14ffeee5e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7432de8165fe68a4fdb1919a33b58250"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga7432de8165fe68a4fdb1919a33b58250">i2c_master_unregister_callback</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga844ac2694772642cfee08a29c50bf054">i2c_master_callback</a> callback_type)</td></tr>
<tr class="memdesc:ga7432de8165fe68a4fdb1919a33b58250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters callback for the specified callback type.  <a href="#ga7432de8165fe68a4fdb1919a33b58250">More...</a><br /></td></tr>
<tr class="separator:ga7432de8165fe68a4fdb1919a33b58250"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Read and Write, Interrupt-driven</h2></td></tr>
<tr class="memitem:ga15590b71928847daf2826c9cc0482717"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga15590b71928847daf2826c9cc0482717">i2c_master_read_bytes</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr class="separator:ga15590b71928847daf2826c9cc0482717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga909337c580a4cd52dd209baaf2d399af"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga909337c580a4cd52dd209baaf2d399af">i2c_master_read_packet_job</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr class="memdesc:ga909337c580a4cd52dd209baaf2d399af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a read packet operation.  <a href="#ga909337c580a4cd52dd209baaf2d399af">More...</a><br /></td></tr>
<tr class="separator:ga909337c580a4cd52dd209baaf2d399af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa56093f3196b0f0ff368fa2ee21827f9"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gaa56093f3196b0f0ff368fa2ee21827f9">i2c_master_read_packet_job_no_stop</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr class="memdesc:gaa56093f3196b0f0ff368fa2ee21827f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a read packet operation without sending a STOP condition when done.  <a href="#gaa56093f3196b0f0ff368fa2ee21827f9">More...</a><br /></td></tr>
<tr class="separator:gaa56093f3196b0f0ff368fa2ee21827f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaff359c3a99851202a0190014d823c29"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gaaff359c3a99851202a0190014d823c29">i2c_master_read_packet_job_no_nack</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr class="memdesc:gaaff359c3a99851202a0190014d823c29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a read packet operation without sending a NACK signal and a STOP condition when done.  <a href="#gaaff359c3a99851202a0190014d823c29">More...</a><br /></td></tr>
<tr class="separator:gaaff359c3a99851202a0190014d823c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f4d4f641c2bb1a905ad95a41ed3f741"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga6f4d4f641c2bb1a905ad95a41ed3f741">i2c_master_write_bytes</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr class="separator:ga6f4d4f641c2bb1a905ad95a41ed3f741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5527434ebf5f0442a9f9ed9146005cba"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga5527434ebf5f0442a9f9ed9146005cba">i2c_master_write_packet_job</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr class="memdesc:ga5527434ebf5f0442a9f9ed9146005cba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a write packet operation.  <a href="#ga5527434ebf5f0442a9f9ed9146005cba">More...</a><br /></td></tr>
<tr class="separator:ga5527434ebf5f0442a9f9ed9146005cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1ee33c8f9b65ede18200b33500dae7d"><td class="memItemLeft" align="right" valign="top">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gaf1ee33c8f9b65ede18200b33500dae7d">i2c_master_write_packet_job_no_stop</a> (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module, struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const packet)</td></tr>
<tr class="memdesc:gaf1ee33c8f9b65ede18200b33500dae7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initiates a write packet operation without sending a STOP condition when done.  <a href="#gaf1ee33c8f9b65ede18200b33500dae7d">More...</a><br /></td></tr>
<tr class="separator:gaf1ee33c8f9b65ede18200b33500dae7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga0ef653593dbacc01735c61e59ec3f0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ef653593dbacc01735c61e59ec3f0da">&#9670;&nbsp;</a></span>i2c_master_callback_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* i2c_master_callback_t) (struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const module)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="gace1e0023f2eee92565496a2e30006548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace1e0023f2eee92565496a2e30006548">&#9670;&nbsp;</a></span>i2c_master_baud_rate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gace1e0023f2eee92565496a2e30006548">i2c_master_baud_rate</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>I<sup>2</sup>C frequencies. </p>
<p>Values for I<sup>2</sup>C speeds supported by the module. The driver will also support setting any other value, in which case set the value in the <a class="el" href="structi2c__master__config.html">i2c_master_config</a> at desired value divided by 1000.</p>
<p>Example: If 10KHz operation is required, give baud_rate in the configuration structure the value 10. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggace1e0023f2eee92565496a2e30006548a24ddfbe034a690d3a553a17508cbd625"></a>I2C_MASTER_BAUD_RATE_100KHZ&#160;</td><td class="fielddoc"><p>Baud rate at 100KHz (Standard-mode) </p>
</td></tr>
<tr><td class="fieldname"><a id="ggace1e0023f2eee92565496a2e30006548a970dccbbc3dd1d01c1070db6d9aa24cb"></a>I2C_MASTER_BAUD_RATE_400KHZ&#160;</td><td class="fielddoc"><p>Baud rate at 400KHz (Fast-mode) </p>
</td></tr>
</table>

</div>
</div>
<a id="ga844ac2694772642cfee08a29c50bf054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga844ac2694772642cfee08a29c50bf054">&#9670;&nbsp;</a></span>i2c_master_callback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga844ac2694772642cfee08a29c50bf054">i2c_master_callback</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback types. </p>
<p>The available callback types for the I<sup>2</sup>C master module. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga844ac2694772642cfee08a29c50bf054a37c3aab3ceb2bddf4b42672386fd64f2"></a>I2C_MASTER_CALLBACK_WRITE_COMPLETE&#160;</td><td class="fielddoc"><p>Callback for packet write complete </p>
</td></tr>
<tr><td class="fieldname"><a id="gga844ac2694772642cfee08a29c50bf054a64edbb1496288626e11b020a887ffcf8"></a>I2C_MASTER_CALLBACK_READ_COMPLETE&#160;</td><td class="fielddoc"><p>Callback for packet read complete </p>
</td></tr>
<tr><td class="fieldname"><a id="gga844ac2694772642cfee08a29c50bf054a97597905a886849275665273da79442f"></a>I2C_MASTER_CALLBACK_ERROR&#160;</td><td class="fielddoc"><p>Callback for error </p>
</td></tr>
<tr><td class="fieldname"><a id="gga844ac2694772642cfee08a29c50bf054a3563390afb1b1b26a6252e0b5981ed06"></a>_I2C_MASTER_CALLBACK_N&#160;</td><td class="fielddoc"><p>Total number of callbacks </p>
</td></tr>
</table>

</div>
</div>
<a id="ga4640bee224bf835f4c38d7702be0742c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4640bee224bf835f4c38d7702be0742c">&#9670;&nbsp;</a></span>i2c_master_inactive_timeout</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga4640bee224bf835f4c38d7702be0742c">i2c_master_inactive_timeout</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values for inactive bus time-out. </p>
<p>If the inactive bus time-out is enabled and the bus is inactive for longer than the time-out setting, the bus state logic will be set to idle. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga4640bee224bf835f4c38d7702be0742ca52414c5127a26a6811f30324102cc3b1"></a>I2C_MASTER_INACTIVE_TIMEOUT_DISABLED&#160;</td><td class="fielddoc"><p>Inactive bus time-out disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4640bee224bf835f4c38d7702be0742ca9e204c432b52e77b4d34a5b64d4432e9"></a>I2C_MASTER_INACTIVE_TIMEOUT_55US&#160;</td><td class="fielddoc"><p>Inactive bus time-out 5-6 SCL cycle time-out </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4640bee224bf835f4c38d7702be0742ca9f37beb962cccc4538b0c226c921c553"></a>I2C_MASTER_INACTIVE_TIMEOUT_105US&#160;</td><td class="fielddoc"><p>Inactive bus time-out 10-11 SCL cycle time-out </p>
</td></tr>
<tr><td class="fieldname"><a id="gga4640bee224bf835f4c38d7702be0742ca7412f98fd47572a75dc17727fdf735d0"></a>I2C_MASTER_INACTIVE_TIMEOUT_205US&#160;</td><td class="fielddoc"><p>Inactive bus time-out 20-21 SCL cycle time-out </p>
</td></tr>
</table>

</div>
</div>
<a id="ga9f73c4fbd225704c2e0da23319c25555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f73c4fbd225704c2e0da23319c25555">&#9670;&nbsp;</a></span>i2c_master_interrupt_flag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga9f73c4fbd225704c2e0da23319c25555">i2c_master_interrupt_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt flags. </p>
<p>Flags used when reading or setting interrupt flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga9f73c4fbd225704c2e0da23319c25555a39c138d5f063f3d43b4e974870364d2e"></a>I2C_MASTER_INTERRUPT_WRITE&#160;</td><td class="fielddoc"><p>Interrupt flag used for write </p>
</td></tr>
<tr><td class="fieldname"><a id="gga9f73c4fbd225704c2e0da23319c25555a3087032aa3a5218a0cdc54179d9e1d09"></a>I2C_MASTER_INTERRUPT_READ&#160;</td><td class="fielddoc"><p>Interrupt flag used for read </p>
</td></tr>
</table>

</div>
</div>
<a id="gadd8aa7cabbddc1cd2c1a8753c9b99d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd8aa7cabbddc1cd2c1a8753c9b99d20">&#9670;&nbsp;</a></span>i2c_master_start_hold_time</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gadd8aa7cabbddc1cd2c1a8753c9b99d20">i2c_master_start_hold_time</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Values for hold time after start bit. </p>
<p>Values for the possible I<sup>2</sup>C master mode SDA internal hold times after start bit has been sent. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ggadd8aa7cabbddc1cd2c1a8753c9b99d20a85f0b592eef5f8b5ecae9f2cca2d4cd1"></a>I2C_MASTER_START_HOLD_TIME_DISABLED&#160;</td><td class="fielddoc"><p>Internal SDA hold time disabled </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd8aa7cabbddc1cd2c1a8753c9b99d20a41403c4a18a1220f031c99e52f384e39"></a>I2C_MASTER_START_HOLD_TIME_50NS_100NS&#160;</td><td class="fielddoc"><p>Internal SDA hold time 50ns - 100ns </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd8aa7cabbddc1cd2c1a8753c9b99d20acc3f7849862510590acc2e3bebc29d0c"></a>I2C_MASTER_START_HOLD_TIME_300NS_600NS&#160;</td><td class="fielddoc"><p>Internal SDA hold time 300ns - 600ns </p>
</td></tr>
<tr><td class="fieldname"><a id="ggadd8aa7cabbddc1cd2c1a8753c9b99d20a38cf380ace8d180528eb34bc38b7da9e"></a>I2C_MASTER_START_HOLD_TIME_400NS_800NS&#160;</td><td class="fielddoc"><p>Internal SDA hold time 400ns - 800ns </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5ba2356881237729e03a8c4637b96306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5ba2356881237729e03a8c4637b96306">&#9670;&nbsp;</a></span>_i2c_master_interrupt_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void _i2c_master_interrupt_handler </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga1c174d923b525f6d60402f66bc9c3451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c174d923b525f6d60402f66bc9c3451">&#9670;&nbsp;</a></span>i2c_master_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="union_sercom.html">Sercom</a> *const&#160;</td>
          <td class="paramname"><em>hw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct <a class="el" href="structi2c__master__config.html">i2c_master_config</a> *const&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the requested I<sup>2</sup>C hardware module. </p>
<p>Initializes the SERCOM I<sup>2</sup>C master device requested and sets the provided software module struct. Run this function before any further use of the driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">module</td><td>Pointer to software module struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hw</td><td>Pointer to the hardware instance </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>Pointer to the configuration struct</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of initialization. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>Module initiated correctly </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If module is enabled </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If module is busy resetting </td></tr>
    <tr><td class="paramname">STATUS_ERR_ALREADY_INITIALIZED</td><td>If setting other GCLK generator than previously set </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAUDRATE_UNAVAILABLE</td><td>If given baudrate is not compatible with set GCLK frequency </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga54cf79ca8aa80e2163881ca4164e35f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54cf79ca8aa80e2163881ca4164e35f7">&#9670;&nbsp;</a></span>i2c_master_read_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_read_byte </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads one byte data from slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to software module struct </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">byte</td><td>Read one byte data to slave</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of reading byte. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>One byte was read successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_TIMEOUT</td><td>If no response was given within specified timeout period </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If error on bus </td></tr>
    <tr><td class="paramname">STATUS_ERR_PACKET_COLLISION</td><td>If arbitration is lost </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_ADDRESS</td><td>If slave is busy, or no slave acknowledged the address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga15590b71928847daf2826c9cc0482717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15590b71928847daf2826c9cc0482717">&#9670;&nbsp;</a></span>i2c_master_read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_read_bytes </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga909337c580a4cd52dd209baaf2d399af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga909337c580a4cd52dd209baaf2d399af">&#9670;&nbsp;</a></span>i2c_master_read_packet_job()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_read_packet_job </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates a read packet operation. </p>
<p>Reads a data packet from the specified slave address on the I<sup>2</sup>C bus. This is the non-blocking equivalent of <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga238a755f972b9c3287131cda5fc25725">i2c_master_read_packet_wait</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to software module struct </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packet</td><td>Pointer to I<sup>2</sup>C packet to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of starting reading I<sup>2</sup>C packet. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If reading was started successfully </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If module is currently busy with another transfer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaaff359c3a99851202a0190014d823c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaff359c3a99851202a0190014d823c29">&#9670;&nbsp;</a></span>i2c_master_read_packet_job_no_nack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_read_packet_job_no_nack </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates a read packet operation without sending a NACK signal and a STOP condition when done. </p>
<p>Reads a data packet from the specified slave address on the I<sup>2</sup>C bus without sending a nack and a stop condition, thus retaining ownership of the bus when done. To end the transaction, a <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga238a755f972b9c3287131cda5fc25725">read</a> or <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga6c07057fe2534e8b4a3ce2cfe2dafc1b">write</a> with stop condition must be performed.</p>
<p>This is the non-blocking equivalent of <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gaa8b27eb9e3a8ae0f907bf7078d4001f0">i2c_master_read_packet_wait_no_stop</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to software module struct </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packet</td><td>Pointer to I<sup>2</sup>C packet to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of starting reading I<sup>2</sup>C packet. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If reading was started successfully </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If module is currently busy with another operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa56093f3196b0f0ff368fa2ee21827f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa56093f3196b0f0ff368fa2ee21827f9">&#9670;&nbsp;</a></span>i2c_master_read_packet_job_no_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_read_packet_job_no_stop </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates a read packet operation without sending a STOP condition when done. </p>
<p>Reads a data packet from the specified slave address on the I<sup>2</sup>C bus without sending a stop condition, thus retaining ownership of the bus when done. To end the transaction, a <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga238a755f972b9c3287131cda5fc25725">read</a> or <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga6c07057fe2534e8b4a3ce2cfe2dafc1b">write</a> with stop condition must be performed.</p>
<p>This is the non-blocking equivalent of <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#gaa8b27eb9e3a8ae0f907bf7078d4001f0">i2c_master_read_packet_wait_no_stop</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to software module struct </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packet</td><td>Pointer to I<sup>2</sup>C packet to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of starting reading I<sup>2</sup>C packet. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If reading was started successfully </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If module is currently busy with another operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga238a755f972b9c3287131cda5fc25725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga238a755f972b9c3287131cda5fc25725">&#9670;&nbsp;</a></span>i2c_master_read_packet_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_read_packet_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data packet from slave. </p>
<p>Reads a data packet from the specified slave address on the I<sup>2</sup>C bus and sends a stop condition when finished.</p>
<dl class="section note"><dt>Note</dt><dd>This will stall the device from any other operation. For interrupt-driven operation, see <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga909337c580a4cd52dd209baaf2d399af">i2c_master_read_packet_job</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to software module struct </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packet</td><td>Pointer to I<sup>2</sup>C packet to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of reading packet. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>The packet was read successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_TIMEOUT</td><td>If no response was given within specified timeout period </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If error on bus </td></tr>
    <tr><td class="paramname">STATUS_ERR_PACKET_COLLISION</td><td>If arbitration is lost </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_ADDRESS</td><td>If slave is busy, or no slave acknowledged the address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae39b9f208966b0857f0bb61dc4dffd83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae39b9f208966b0857f0bb61dc4dffd83">&#9670;&nbsp;</a></span>i2c_master_read_packet_wait_no_nack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_read_packet_wait_no_nack </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="gaa8b27eb9e3a8ae0f907bf7078d4001f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa8b27eb9e3a8ae0f907bf7078d4001f0">&#9670;&nbsp;</a></span>i2c_master_read_packet_wait_no_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_read_packet_wait_no_stop </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data packet from slave without sending a stop condition when done. </p>
<p>Reads a data packet from the specified slave address on the I<sup>2</sup>C bus without sending a stop condition when done, thus retaining ownership of the bus when done. To end the transaction, a <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga238a755f972b9c3287131cda5fc25725">read</a> or <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga6c07057fe2534e8b4a3ce2cfe2dafc1b">write</a> with stop condition must be performed.</p>
<dl class="section note"><dt>Note</dt><dd>This will stall the device from any other operation. For interrupt-driven operation, see <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga909337c580a4cd52dd209baaf2d399af">i2c_master_read_packet_job</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to software module struct </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packet</td><td>Pointer to I<sup>2</sup>C packet to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of reading packet. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>The packet was read successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_TIMEOUT</td><td>If no response was given within specified timeout period </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If error on bus </td></tr>
    <tr><td class="paramname">STATUS_ERR_PACKET_COLLISION</td><td>If arbitration is lost </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_ADDRESS</td><td>If slave is busy, or no slave acknowledged the address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf3216a045490437ec87ba14ffeee5e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3216a045490437ec87ba14ffeee5e7b">&#9670;&nbsp;</a></span>i2c_master_register_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_master_register_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga0ef653593dbacc01735c61e59ec3f0da">i2c_master_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga844ac2694772642cfee08a29c50bf054">i2c_master_callback</a>&#160;</td>
          <td class="paramname"><em>callback_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Registers callback for the specified callback type. </p>
<p>Associates the given callback function with the specified callback type.</p>
<p>To enable the callback, the i2c_master_enable_callback function must be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software module struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback</td><td>Pointer to the function desired for the specified callback </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_type</td><td>Callback type to register </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6dc5e9982ce4d7c6acc68cb69c57883d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6dc5e9982ce4d7c6acc68cb69c57883d">&#9670;&nbsp;</a></span>i2c_master_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_master_reset </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the hardware module. </p>
<p>Reset the module to hardware defaults.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to software module structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf9bb3b3174c1fc602c3097bc40eadcef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf9bb3b3174c1fc602c3097bc40eadcef">&#9670;&nbsp;</a></span>i2c_master_send_nack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_master_send_nack </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends nack signal on bus. </p>
<p>Sends a nack signal on bus.</p>
<dl class="section note"><dt>Note</dt><dd>This function can only be used after the i2c_master_write_packet_wait_no_nack function, or <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga54cf79ca8aa80e2163881ca4164e35f7">i2c_master_read_byte</a> function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6bddf9e717847b5fa8462596e7e1489c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bddf9e717847b5fa8462596e7e1489c">&#9670;&nbsp;</a></span>i2c_master_send_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_master_send_stop </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends stop condition on bus. </p>
<p>Sends a stop condition on bus.</p>
<dl class="section note"><dt>Note</dt><dd>This function can only be used after the <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga4d874599c2bff10cd08f5474041c66bb">i2c_master_write_packet_wait_no_stop</a> function. If a stop condition is to be sent after a read, the <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga238a755f972b9c3287131cda5fc25725">i2c_master_read_packet_wait</a> function must be used.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software instance struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga7432de8165fe68a4fdb1919a33b58250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7432de8165fe68a4fdb1919a33b58250">&#9670;&nbsp;</a></span>i2c_master_unregister_callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void i2c_master_unregister_callback </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga844ac2694772642cfee08a29c50bf054">i2c_master_callback</a>&#160;</td>
          <td class="paramname"><em>callback_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unregisters callback for the specified callback type. </p>
<p>When called, the currently registered callback for the given callback type will be removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to the software module struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">callback_type</td><td>Specifies the callback type to unregister </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee2de09ec9474331f354eec703b80b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee2de09ec9474331f354eec703b80b6e">&#9670;&nbsp;</a></span>i2c_master_write_byte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_write_byte </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write one byte data to slave. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to software module struct </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">byte</td><td>Send one byte data to slave</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of writing byte. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>One byte was write successfully </td></tr>
    <tr><td class="paramname">STATUS_ERR_TIMEOUT</td><td>If no response was given within specified timeout period </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If error on bus </td></tr>
    <tr><td class="paramname">STATUS_ERR_PACKET_COLLISION</td><td>If arbitration is lost </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_ADDRESS</td><td>If slave is busy, or no slave acknowledged the address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6f4d4f641c2bb1a905ad95a41ed3f741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f4d4f641c2bb1a905ad95a41ed3f741">&#9670;&nbsp;</a></span>i2c_master_write_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_write_bytes </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ga5527434ebf5f0442a9f9ed9146005cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5527434ebf5f0442a9f9ed9146005cba">&#9670;&nbsp;</a></span>i2c_master_write_packet_job()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_write_packet_job </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates a write packet operation. </p>
<p>Writes a data packet to the specified slave address on the I<sup>2</sup>C bus. This is the non-blocking equivalent of <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga6c07057fe2534e8b4a3ce2cfe2dafc1b">i2c_master_write_packet_wait</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to software module struct </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packet</td><td>Pointer to I<sup>2</sup>C packet to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of starting writing I<sup>2</sup>C packet job. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If writing was started successfully </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If module is currently busy with another transfer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf1ee33c8f9b65ede18200b33500dae7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf1ee33c8f9b65ede18200b33500dae7d">&#9670;&nbsp;</a></span>i2c_master_write_packet_job_no_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_write_packet_job_no_stop </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initiates a write packet operation without sending a STOP condition when done. </p>
<p>Writes a data packet to the specified slave address on the I<sup>2</sup>C bus without sending a stop condition, thus retaining ownership of the bus when done. To end the transaction, a <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga238a755f972b9c3287131cda5fc25725">read</a> or <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga6c07057fe2534e8b4a3ce2cfe2dafc1b">write</a> with stop condition or sending a stop with the <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga6bddf9e717847b5fa8462596e7e1489c">i2c_master_send_stop</a> function must be performed.</p>
<p>This is the non-blocking equivalent of <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga4d874599c2bff10cd08f5474041c66bb">i2c_master_write_packet_wait_no_stop</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to software module struct </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packet</td><td>Pointer to I<sup>2</sup>C packet to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of starting writing I<sup>2</sup>C packet job. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If writing was started successfully </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If module is currently busy with another </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6c07057fe2534e8b4a3ce2cfe2dafc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c07057fe2534e8b4a3ce2cfe2dafc1b">&#9670;&nbsp;</a></span>i2c_master_write_packet_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_write_packet_wait </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data packet to slave. </p>
<p>Writes a data packet to the specified slave address on the I<sup>2</sup>C bus and sends a stop condition when finished.</p>
<dl class="section note"><dt>Note</dt><dd>This will stall the device from any other operation. For interrupt-driven operation, see <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga909337c580a4cd52dd209baaf2d399af">i2c_master_read_packet_job</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to software module struct </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packet</td><td>Pointer to I<sup>2</sup>C packet to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of write packet. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If packet was write successfully </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If master module is busy with a job </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If error on bus </td></tr>
    <tr><td class="paramname">STATUS_ERR_PACKET_COLLISION</td><td>If arbitration is lost </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_ADDRESS</td><td>If slave is busy, or no slave acknowledged the address </td></tr>
    <tr><td class="paramname">STATUS_ERR_TIMEOUT</td><td>If timeout occurred </td></tr>
    <tr><td class="paramname">STATUS_ERR_OVERFLOW</td><td>If slave did not acknowledge last sent data, indicating that slave does not want more data and was not able to read last data sent </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d874599c2bff10cd08f5474041c66bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d874599c2bff10cd08f5474041c66bb">&#9670;&nbsp;</a></span>i2c_master_write_packet_wait_no_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__group__sam0__utils__status__codes.html#ga751c892e5a46b8e7d282085a5a5bf151">status_code</a> i2c_master_write_packet_wait_no_stop </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__module.html">i2c_master_module</a> *const&#160;</td>
          <td class="paramname"><em>module</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structi2c__master__packet.html">i2c_master_packet</a> *const&#160;</td>
          <td class="paramname"><em>packet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data packet to slave without sending a stop condition when done. </p>
<p>Writes a data packet to the specified slave address on the I<sup>2</sup>C bus without sending a stop condition, thus retaining ownership of the bus when done. To end the transaction, a <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga238a755f972b9c3287131cda5fc25725">read</a> or <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga6c07057fe2534e8b4a3ce2cfe2dafc1b">write</a> with stop condition or sending a stop with the <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga6bddf9e717847b5fa8462596e7e1489c">i2c_master_send_stop</a> function must be performed.</p>
<dl class="section note"><dt>Note</dt><dd>This will stall the device from any other operation. For interrupt-driven operation, see <a class="el" href="group__asfdoc__sam0__sercom__i2c__group.html#ga909337c580a4cd52dd209baaf2d399af">i2c_master_read_packet_job</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">module</td><td>Pointer to software module struct </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">packet</td><td>Pointer to I<sup>2</sup>C packet to transfer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Status of write packet. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">STATUS_OK</td><td>If packet was write successfully </td></tr>
    <tr><td class="paramname">STATUS_BUSY</td><td>If master module is busy </td></tr>
    <tr><td class="paramname">STATUS_ERR_DENIED</td><td>If error on bus </td></tr>
    <tr><td class="paramname">STATUS_ERR_PACKET_COLLISION</td><td>If arbitration is lost </td></tr>
    <tr><td class="paramname">STATUS_ERR_BAD_ADDRESS</td><td>If slave is busy, or no slave acknowledged the address </td></tr>
    <tr><td class="paramname">STATUS_ERR_TIMEOUT</td><td>If timeout occurred </td></tr>
    <tr><td class="paramname">STATUS_ERR_OVERFLOW</td><td>If slave did not acknowledge last sent data, indicating that slave do not want more data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
